/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./SyncUnit_v2TMR.v                                                                     *
 *                                                                                                  *
 * user    : gianni                                                                                 *
 * host    : elt153xl.to.infn.it                                                                    *
 * date    : 16/03/2021 13:18:31                                                                    *
 *                                                                                                  *
 * workdir : /export/elt153xl/disk0/users/gianni/projects/LiTE-DTU/v2/netlist_in                    *
 * cmd     : /export/elt153xl/disk0/users/gianni/projects/LiTE-DTU/tmrg/bin/tmrg --sdc-generate --sdc- *
 *           headers --config SyncUnit_v2.cfg SyncUnit_v2.v                                         *
 * tmrg rev: 9a6ee4d64fce05b58c62ee9ecfc4ef5a8551d404                                               *
 *                                                                                                  *
 * src file: SyncUnit_v2.v                                                                          *
 *           File is NOT under version control!                                                     *
 *           Modification time : 2021-03-16 13:18:10.773962                                         *
 *           File Size         : 11611                                                              *
 *           MD5 hash          : e07641d9cb602b49888edf9baaf39586                                   *
 *                                                                                                  *
 ****************************************************************************************************/
`timescale  1ps/1ps
module SyncUnit_v2TMR #(
  parameter NBitsEnc=8,
  parameter NBits=4
)(
  input  rst_bA,
  input  rst_bB,
  input  rst_bC,
  input  clockA,
  input  clockB,
  input  clockC,
  input  serial_inA,
  input  serial_inB,
  input  serial_inC,
  output reg  DtuRst_bA,
  output reg  DtuRst_bB,
  output reg  DtuRst_bC,
  output  i2cRst_bA,
  output  i2cRst_bB,
  output  i2cRst_bC,
  output reg  atuRst_bA,
  output reg  atuRst_bB,
  output reg  atuRst_bC,
  output reg  DtuSyncModeA,
  output reg  DtuSyncModeB,
  output reg  DtuSyncModeC,
  output reg  DtuFlushA,
  output reg  DtuFlushB,
  output reg  DtuFlushC,
  output reg [1:0] AdcRst_bA,
  output reg [1:0] AdcRst_bB,
  output reg [1:0] AdcRst_bC,
  output [1:0] AdcCalA,
  output [1:0] AdcCalB,
  output [1:0] AdcCalC,
  output reg  PllLockStartA,
  output reg  PllLockStartB,
  output reg  PllLockStartC,
  output reg  CatiaTPA,
  output reg  CatiaTPB,
  output reg  CatiaTPC,
  output reg  BC0markA,
  output reg  BC0markB,
  output reg  BC0markC,
  input [7:0] TP_len,
  input [1:0] AdcCalBusyIn,
  input [1:0] AdcOvfIn,
  input [1:0] AdcSeuIn,
  output  AdcCalBusyOut,
  output  AdcOvfOut,
  output  AdcSeuOut,
  input [1:0] TmrErrIn,
  output reg  TmrErrOut
);
localparam    rd_idle=2'b00;
localparam    rd_load=2'b01;
localparam    rd_wait=2'b11;
localparam    dec_idle=5'b00000;
localparam    dec_aHr=5'b00001;
localparam    dec_aLr=5'b00010;
localparam    dec_DTUr=5'b00011;
localparam    dec_I2Cr=5'b00100;
localparam    dec_ATUr=5'b00101;
localparam    dec_aHc=5'b00110;
localparam    dec_aLc=5'b00111;
localparam    dec_DTUs=5'b01000;
localparam    dec_DTUn=5'b01001;
localparam    dec_Plock=5'b01010;
localparam    dec_marker=5'b01011;
localparam    dec_mwait=5'b11011;
localparam    dec_Ctp_1=5'b01100;
localparam    dec_Ctp_2=5'b01101;
localparam    dec_DTUf=5'b01110;
localparam    dec_wait=5'b01111;
localparam    start=8'b00000111;
localparam    stop=8'b00000000;
localparam    dtu_rst=4'b0010;
localparam    i2c_rst=4'b0011;
localparam    dtu_sm=4'b0101;
localparam    dtu_nm=4'b0110;
localparam    dtu_fl=4'b0111;
localparam    atu_rst=4'b0100;
localparam    adcH_rst=4'b1000;
localparam    adcH_cal=4'b1001;
localparam    adcL_rst=4'b1010;
localparam    adcL_cal=4'b1011;
localparam    pll_lock=4'b1100;
localparam    catia_tp=4'b1101;
localparam    bc0_mark=4'b1110;
wire [7:0] TP_lenC;
wire [7:0] TP_lenB;
wire [7:0] TP_lenA;
wire [1:0] TmrErrInC;
wire [1:0] TmrErrInB;
wire [1:0] TmrErrInA;
wire tmrErrorC;
wor iCatiaTPTmrErrorC;
wire iCatiaTPVotedC;
wor Flush_dlyTmrErrorC;
wire [1:0] Flush_dlyVotedC;
wor iFlushTmrErrorC;
wire iFlushVotedC;
wor nState1TmrErrorC;
wire [4:0] nState1VotedC;
wor nextSyncModeTmrErrorC;
wire nextSyncModeVotedC;
wor iBC0markTmrErrorC;
wire iBC0markVotedC;
wor iAtuRst_bTmrErrorC;
wire iAtuRst_bVotedC;
wor iDtuRst_bTmrErrorC;
wire iDtuRst_bVotedC;
wor nState0TmrErrorC;
wire [1:0] nState0VotedC;
wor iAdcRst_bTmrErrorC;
wire [1:0] iAdcRst_bVotedC;
wor iPllLockStartTmrErrorC;
wire iPllLockStartVotedC;
wire tmrErrorB;
wor iCatiaTPTmrErrorB;
wire iCatiaTPVotedB;
wor iDtuRst_bTmrErrorB;
wire iDtuRst_bVotedB;
wor nState1TmrErrorB;
wire [4:0] nState1VotedB;
wor Flush_dlyTmrErrorB;
wire [1:0] Flush_dlyVotedB;
wor iBC0markTmrErrorB;
wire iBC0markVotedB;
wor iFlushTmrErrorB;
wire iFlushVotedB;
wor iAtuRst_bTmrErrorB;
wire iAtuRst_bVotedB;
wor nextSyncModeTmrErrorB;
wire nextSyncModeVotedB;
wor nState0TmrErrorB;
wire [1:0] nState0VotedB;
wor iPllLockStartTmrErrorB;
wire iPllLockStartVotedB;
wor iAdcRst_bTmrErrorB;
wire [1:0] iAdcRst_bVotedB;
wire tmrErrorA;
wor iAtuRst_bTmrErrorA;
wire iAtuRst_bVotedA;
wor Flush_dlyTmrErrorA;
wire [1:0] Flush_dlyVotedA;
wor iCatiaTPTmrErrorA;
wire iCatiaTPVotedA;
wor nState1TmrErrorA;
wire [4:0] nState1VotedA;
wor iBC0markTmrErrorA;
wire iBC0markVotedA;
wor iFlushTmrErrorA;
wire iFlushVotedA;
wor iDtuRst_bTmrErrorA;
wire iDtuRst_bVotedA;
wor nextSyncModeTmrErrorA;
wire nextSyncModeVotedA;
wor iAdcRst_bTmrErrorA;
wire [1:0] iAdcRst_bVotedA;
wor iPllLockStartTmrErrorA;
wire iPllLockStartVotedA;
wor nState0TmrErrorA;
wire [1:0] nState0VotedA;
wire tmrError;
wor int_TmrErrOutTmrError;
wire int_TmrErrOut;
wor clockTmrError;
wire clock;
wor rst_bTmrError;
wire rst_b;
reg  [NBitsEnc:0] ShiftRegisterA;
reg  [NBitsEnc:0] ShiftRegisterB;
reg  [NBitsEnc:0] ShiftRegisterC;
wire [NBits-1:0] DecoderOutA;
wire [NBits-1:0] DecoderOutB;
wire [NBits-1:0] DecoderOutC;
reg  [NBits-1:0] InstrRegA;
reg  [NBits-1:0] InstrRegB;
reg  [NBits-1:0] InstrRegC;
reg  IR_loadA;
reg  IR_loadB;
reg  IR_loadC;
reg  [9:0] TP_counterA;
reg  [9:0] TP_counterB;
reg  [9:0] TP_counterC;
reg  TPcnt_rstA;
reg  TPcnt_rstB;
reg  TPcnt_rstC;
reg  TPcnt_cenA;
reg  TPcnt_cenB;
reg  TPcnt_cenC;
wire TPcnt_eocA;
wire TPcnt_eocB;
wire TPcnt_eocC;
wire int_TmrErrOutA;
wire int_TmrErrOutB;
wire int_TmrErrOutC;
reg  [1:0] AdcIntCalA;
reg  [1:0] AdcIntCalB;
reg  [1:0] AdcIntCalC;
reg  nextSyncModeA;
reg  nextSyncModeB;
reg  nextSyncModeC;
reg  iDtuRst_bA;
reg  iDtuRst_bB;
reg  iDtuRst_bC;
reg  iAtuRst_bA;
reg  iAtuRst_bB;
reg  iAtuRst_bC;
reg  [1:0] iAdcRst_bA;
reg  [1:0] iAdcRst_bB;
reg  [1:0] iAdcRst_bC;
reg  iPllLockStartA;
reg  iPllLockStartB;
reg  iPllLockStartC;
reg  iCatiaTPA;
reg  iCatiaTPB;
reg  iCatiaTPC;
reg  iBC0markA;
reg  iBC0markB;
reg  iBC0markC;
reg  [1:0] cState0A;
reg  [1:0] cState0B;
reg  [1:0] cState0C;
reg  [1:0] nState0A;
reg  [1:0] nState0B;
reg  [1:0] nState0C;
reg  [4:0] cState1A;
reg  [4:0] cState1B;
reg  [4:0] cState1C;
reg  [4:0] nState1A;
reg  [4:0] nState1B;
reg  [4:0] nState1C;
reg  [2:0] counterA;
reg  [2:0] counterB;
reg  [2:0] counterC;
reg  cnt_rstA;
reg  cnt_rstB;
reg  cnt_rstC;
wire cnt_eocA;
wire cnt_eocB;
wire cnt_eocC;
reg  int_i2cRst_bA;
reg  int_i2cRst_bB;
reg  int_i2cRst_bC;
reg  iFlushA;
reg  iFlushB;
reg  iFlushC;
reg  [1:0] Flush_dlyA;
reg  [1:0] Flush_dlyB;
reg  [1:0] Flush_dlyC;
wire asynch_i2cRst_bA;
wire asynch_i2cRst_bB;
wire asynch_i2cRst_bC;
wire encoding_errorA;
wire encoding_errorB;
wire encoding_errorC;
wire errorVotedA =  tmrErrorA;
wire errorVotedB =  tmrErrorB;
wire errorVotedC =  tmrErrorC;

always @( posedge clockA )
  begin
    DtuRst_bA =  iDtuRst_bVotedA;
    atuRst_bA =  iAtuRst_bVotedA;
    AdcRst_bA =  iAdcRst_bVotedA;
    PllLockStartA =  iPllLockStartVotedA;
    CatiaTPA =  iCatiaTPVotedA;
    BC0markA =  iBC0markVotedA;
    DtuFlushA =  iFlushVotedA|Flush_dlyVotedA[1] ;
  end

always @( posedge clockB )
  begin
    DtuRst_bB =  iDtuRst_bVotedB;
    atuRst_bB =  iAtuRst_bVotedB;
    AdcRst_bB =  iAdcRst_bVotedB;
    PllLockStartB =  iPllLockStartVotedB;
    CatiaTPB =  iCatiaTPVotedB;
    BC0markB =  iBC0markVotedB;
    DtuFlushB =  iFlushVotedB|Flush_dlyVotedB[1] ;
  end

always @( posedge clockC )
  begin
    DtuRst_bC =  iDtuRst_bVotedC;
    atuRst_bC =  iAtuRst_bVotedC;
    AdcRst_bC =  iAdcRst_bVotedC;
    PllLockStartC =  iPllLockStartVotedC;
    CatiaTPC =  iCatiaTPVotedC;
    BC0markC =  iBC0markVotedC;
    DtuFlushC =  iFlushVotedC|Flush_dlyVotedC[1] ;
  end

	deglitch rstA_deglitch (.A(rst_bA), .Z(asynch_i2cRst_bA));
	deglitch rstB_deglitch (.A(rst_bB), .Z(asynch_i2cRst_bB));
	deglitch rstC_deglitch (.A(rst_bC), .Z(asynch_i2cRst_bC));

assign i2cRst_bA =  int_i2cRst_bA&asynch_i2cRst_bA;
assign i2cRst_bB =  int_i2cRst_bB&asynch_i2cRst_bB;
assign i2cRst_bC =  int_i2cRst_bC&asynch_i2cRst_bC;
assign AdcCalBusyOut =  AdcCalBusyIn[1] |AdcCalBusyIn[0] ;
assign AdcOvfOut =  AdcOvfIn[1] |AdcOvfIn[0] ;
assign AdcSeuOut =  AdcSeuIn[1] |AdcSeuIn[0] ;
assign int_TmrErrOutA =  TmrErrInA[1] |TmrErrInA[0] |errorVotedA;
assign int_TmrErrOutB =  TmrErrInB[1] |TmrErrInB[0] |errorVotedB;
assign int_TmrErrOutC =  TmrErrInC[1] |TmrErrInC[0] |errorVotedC;

always @( posedge clock )
  begin
    if (rst_b==0)
      TmrErrOut =  1'b0;
    else
      TmrErrOut =  int_TmrErrOut;
  end

always @( posedge clockA )
  begin
    if (rst_bA==0)
      ShiftRegisterA <= 'h0;
    else
      ShiftRegisterA <= {ShiftRegisterA[NBitsEnc-1:0] ,serial_inA};
  end

always @( posedge clockB )
  begin
    if (rst_bB==0)
      ShiftRegisterB <= 'h0;
    else
      ShiftRegisterB <= {ShiftRegisterB[NBitsEnc-1:0] ,serial_inB};
  end

always @( posedge clockC )
  begin
    if (rst_bC==0)
      ShiftRegisterC <= 'h0;
    else
      ShiftRegisterC <= {ShiftRegisterC[NBitsEnc-1:0] ,serial_inC};
  end

HammingDecoder4TMR #(.NBits(NBits), .NBitsEnc(NBitsEnc)) I_Decoder (
    .data_encA(ShiftRegisterA[NBitsEnc:1] ),
    .data_encB(ShiftRegisterB[NBitsEnc:1] ),
    .data_encC(ShiftRegisterC[NBitsEnc:1] ),
    .data_outA(DecoderOutA),
    .data_outB(DecoderOutB),
    .data_outC(DecoderOutC),
    .SEU_errorA(encoding_errorA),
    .SEU_errorB(encoding_errorB),
    .SEU_errorC(encoding_errorC)
    );

always @( cState0A or ShiftRegisterA or cnt_eocA )
  begin
    cnt_rstA =  1'b1;
    IR_loadA =  1'b0;
    case (cState0A)
      rd_idle : 
        begin
          if (ShiftRegisterA[NBitsEnc-1:0] ==start)
            nState0A =  rd_load;
          else
            nState0A =  rd_idle;
        end
      rd_load : 
        begin
          cnt_rstA =  1'b0;
          IR_loadA =  1'b1;
          if (ShiftRegisterA[NBitsEnc-1:0] ==stop)
            nState0A =  rd_idle;
          else
            nState0A =  rd_wait;
        end
      rd_wait : 
        begin
          cnt_rstA =  1'b0;
          if (cnt_eocA==0)
            nState0A =  rd_wait;
          else
            nState0A =  rd_load;
        end
      default : nState0A =  rd_idle;
    endcase
  end

always @( cState0B or ShiftRegisterB or cnt_eocB )
  begin
    cnt_rstB =  1'b1;
    IR_loadB =  1'b0;
    case (cState0B)
      rd_idle : 
        begin
          if (ShiftRegisterB[NBitsEnc-1:0] ==start)
            nState0B =  rd_load;
          else
            nState0B =  rd_idle;
        end
      rd_load : 
        begin
          cnt_rstB =  1'b0;
          IR_loadB =  1'b1;
          if (ShiftRegisterB[NBitsEnc-1:0] ==stop)
            nState0B =  rd_idle;
          else
            nState0B =  rd_wait;
        end
      rd_wait : 
        begin
          cnt_rstB =  1'b0;
          if (cnt_eocB==0)
            nState0B =  rd_wait;
          else
            nState0B =  rd_load;
        end
      default : nState0B =  rd_idle;
    endcase
  end

always @( cState0C or ShiftRegisterC or cnt_eocC )
  begin
    cnt_rstC =  1'b1;
    IR_loadC =  1'b0;
    case (cState0C)
      rd_idle : 
        begin
          if (ShiftRegisterC[NBitsEnc-1:0] ==start)
            nState0C =  rd_load;
          else
            nState0C =  rd_idle;
        end
      rd_load : 
        begin
          cnt_rstC =  1'b0;
          IR_loadC =  1'b1;
          if (ShiftRegisterC[NBitsEnc-1:0] ==stop)
            nState0C =  rd_idle;
          else
            nState0C =  rd_wait;
        end
      rd_wait : 
        begin
          cnt_rstC =  1'b0;
          if (cnt_eocC==0)
            nState0C =  rd_wait;
          else
            nState0C =  rd_load;
        end
      default : nState0C =  rd_idle;
    endcase
  end
assign AdcCalA[0]  =  AdcIntCalA[0] ;
assign AdcCalB[0]  =  AdcIntCalB[0] ;
assign AdcCalC[0]  =  AdcIntCalC[0] ;
assign AdcCalA[1]  =  AdcIntCalA[1] ;
assign AdcCalB[1]  =  AdcIntCalB[1] ;
assign AdcCalC[1]  =  AdcIntCalC[1] ;

always @( cState0A or cState1A or InstrRegA or cnt_eocA or TPcnt_eocA or DtuSyncModeA )
  begin
    iAdcRst_bA =  2'b11;
    AdcIntCalA =  2'b00;
    iDtuRst_bA =  1'b1;
    int_i2cRst_bA =  1'b1;
    iAtuRst_bA =  1'b1;
    nextSyncModeA =  DtuSyncModeA;
    #1 iFlushA =  1'b0;
    iPllLockStartA =  1'b0;
    iCatiaTPA =  1'b0;
    iBC0markA =  1'b0;
    TPcnt_rstA =  1'b1;
    TPcnt_cenA =  1'b0;
    case (cState1A)
      dec_idle : 
        begin
          case (InstrRegA)
            dtu_rst : nState1A =  dec_DTUr;
            i2c_rst : nState1A =  dec_I2Cr;
            dtu_sm : nState1A =  dec_DTUs;
            dtu_nm : nState1A =  dec_DTUn;
            atu_rst : nState1A =  dec_ATUr;
            dtu_fl : nState1A =  dec_DTUf;
            adcH_rst : nState1A =  dec_aHr;
            adcL_rst : nState1A =  dec_aLr;
            adcH_cal : nState1A =  dec_aHc;
            adcL_cal : nState1A =  dec_aLc;
            pll_lock : nState1A =  dec_Plock;
            catia_tp : nState1A =  dec_Ctp_1;
            bc0_mark : nState1A =  dec_marker;
            default : nState1A =  dec_idle;
          endcase
        end
      dec_DTUr : 
        begin
          iDtuRst_bA =  1'b0;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_DTUr;
        end
      dec_I2Cr : 
        begin
          int_i2cRst_bA =  1'b0;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_I2Cr;
        end
      dec_DTUs : 
        begin
          nextSyncModeA =  1'b1;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_DTUs;
        end
      dec_DTUn : 
        begin
          nextSyncModeA =  1'b0;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_DTUn;
        end
      dec_DTUf : 
        begin
          #1 iFlushA =  1'b1;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_DTUf;
        end
      dec_ATUr : 
        begin
          iAtuRst_bA =  1'b0;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_ATUr;
        end
      dec_aHr : 
        begin
          iAdcRst_bA[1]  =  1'b0;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_aHr;
        end
      dec_aLr : 
        begin
          iAdcRst_bA[0]  =  1'b0;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_aLr;
        end
      dec_aHc : 
        begin
          AdcIntCalA[1]  =  1'b1;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_aHc;
        end
      dec_aLc : 
        begin
          AdcIntCalA[0]  =  1'b1;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_aLc;
        end
      dec_Plock : 
        begin
          iPllLockStartA =  1'b1;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_Plock;
        end
      dec_marker : 
        begin
          iBC0markA =  1'b1;
          nState1A =  dec_mwait;
        end
      dec_mwait : 
        begin
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_mwait;
        end
      dec_Ctp_1 : 
        begin
          TPcnt_rstA =  1'b0;
          TPcnt_cenA =  1'b1;
          iCatiaTPA =  1'b1;
          if (TPcnt_eocA==1'b1)
            nState1A =  dec_Ctp_2;
          else
            nState1A =  dec_Ctp_1;
        end
      dec_Ctp_2 : 
        begin
          TPcnt_rstA =  1'b0;
          TPcnt_cenA =  1'b0;
          iCatiaTPA =  1'b0;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_Ctp_2;
        end
      dec_wait : nState1A =  dec_idle;
      default : nState1A =  dec_idle;
    endcase
  end

always @( cState0B or cState1B or InstrRegB or cnt_eocB or TPcnt_eocB or DtuSyncModeB )
  begin
    iAdcRst_bB =  2'b11;
    AdcIntCalB =  2'b00;
    iDtuRst_bB =  1'b1;
    int_i2cRst_bB =  1'b1;
    iAtuRst_bB =  1'b1;
    nextSyncModeB =  DtuSyncModeB;
    #1 iFlushB =  1'b0;
    iPllLockStartB =  1'b0;
    iCatiaTPB =  1'b0;
    iBC0markB =  1'b0;
    TPcnt_rstB =  1'b1;
    TPcnt_cenB =  1'b0;
    case (cState1B)
      dec_idle : 
        begin
          case (InstrRegB)
            dtu_rst : nState1B =  dec_DTUr;
            i2c_rst : nState1B =  dec_I2Cr;
            dtu_sm : nState1B =  dec_DTUs;
            dtu_nm : nState1B =  dec_DTUn;
            atu_rst : nState1B =  dec_ATUr;
            dtu_fl : nState1B =  dec_DTUf;
            adcH_rst : nState1B =  dec_aHr;
            adcL_rst : nState1B =  dec_aLr;
            adcH_cal : nState1B =  dec_aHc;
            adcL_cal : nState1B =  dec_aLc;
            pll_lock : nState1B =  dec_Plock;
            catia_tp : nState1B =  dec_Ctp_1;
            bc0_mark : nState1B =  dec_marker;
            default : nState1B =  dec_idle;
          endcase
        end
      dec_DTUr : 
        begin
          iDtuRst_bB =  1'b0;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_DTUr;
        end
      dec_I2Cr : 
        begin
          int_i2cRst_bB =  1'b0;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_I2Cr;
        end
      dec_DTUs : 
        begin
          nextSyncModeB =  1'b1;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_DTUs;
        end
      dec_DTUn : 
        begin
          nextSyncModeB =  1'b0;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_DTUn;
        end
      dec_DTUf : 
        begin
          #1 iFlushB =  1'b1;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_DTUf;
        end
      dec_ATUr : 
        begin
          iAtuRst_bB =  1'b0;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_ATUr;
        end
      dec_aHr : 
        begin
          iAdcRst_bB[1]  =  1'b0;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_aHr;
        end
      dec_aLr : 
        begin
          iAdcRst_bB[0]  =  1'b0;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_aLr;
        end
      dec_aHc : 
        begin
          AdcIntCalB[1]  =  1'b1;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_aHc;
        end
      dec_aLc : 
        begin
          AdcIntCalB[0]  =  1'b1;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_aLc;
        end
      dec_Plock : 
        begin
          iPllLockStartB =  1'b1;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_Plock;
        end
      dec_marker : 
        begin
          iBC0markB =  1'b1;
          nState1B =  dec_mwait;
        end
      dec_mwait : 
        begin
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_mwait;
        end
      dec_Ctp_1 : 
        begin
          TPcnt_rstB =  1'b0;
          TPcnt_cenB =  1'b1;
          iCatiaTPB =  1'b1;
          if (TPcnt_eocB==1'b1)
            nState1B =  dec_Ctp_2;
          else
            nState1B =  dec_Ctp_1;
        end
      dec_Ctp_2 : 
        begin
          TPcnt_rstB =  1'b0;
          TPcnt_cenB =  1'b0;
          iCatiaTPB =  1'b0;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_Ctp_2;
        end
      dec_wait : nState1B =  dec_idle;
      default : nState1B =  dec_idle;
    endcase
  end

always @( cState0C or cState1C or InstrRegC or cnt_eocC or TPcnt_eocC or DtuSyncModeC )
  begin
    iAdcRst_bC =  2'b11;
    AdcIntCalC =  2'b00;
    iDtuRst_bC =  1'b1;
    int_i2cRst_bC =  1'b1;
    iAtuRst_bC =  1'b1;
    nextSyncModeC =  DtuSyncModeC;
    #1 iFlushC =  1'b0;
    iPllLockStartC =  1'b0;
    iCatiaTPC =  1'b0;
    iBC0markC =  1'b0;
    TPcnt_rstC =  1'b1;
    TPcnt_cenC =  1'b0;
    case (cState1C)
      dec_idle : 
        begin
          case (InstrRegC)
            dtu_rst : nState1C =  dec_DTUr;
            i2c_rst : nState1C =  dec_I2Cr;
            dtu_sm : nState1C =  dec_DTUs;
            dtu_nm : nState1C =  dec_DTUn;
            atu_rst : nState1C =  dec_ATUr;
            dtu_fl : nState1C =  dec_DTUf;
            adcH_rst : nState1C =  dec_aHr;
            adcL_rst : nState1C =  dec_aLr;
            adcH_cal : nState1C =  dec_aHc;
            adcL_cal : nState1C =  dec_aLc;
            pll_lock : nState1C =  dec_Plock;
            catia_tp : nState1C =  dec_Ctp_1;
            bc0_mark : nState1C =  dec_marker;
            default : nState1C =  dec_idle;
          endcase
        end
      dec_DTUr : 
        begin
          iDtuRst_bC =  1'b0;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_DTUr;
        end
      dec_I2Cr : 
        begin
          int_i2cRst_bC =  1'b0;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_I2Cr;
        end
      dec_DTUs : 
        begin
          nextSyncModeC =  1'b1;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_DTUs;
        end
      dec_DTUn : 
        begin
          nextSyncModeC =  1'b0;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_DTUn;
        end
      dec_DTUf : 
        begin
          #1 iFlushC =  1'b1;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_DTUf;
        end
      dec_ATUr : 
        begin
          iAtuRst_bC =  1'b0;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_ATUr;
        end
      dec_aHr : 
        begin
          iAdcRst_bC[1]  =  1'b0;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_aHr;
        end
      dec_aLr : 
        begin
          iAdcRst_bC[0]  =  1'b0;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_aLr;
        end
      dec_aHc : 
        begin
          AdcIntCalC[1]  =  1'b1;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_aHc;
        end
      dec_aLc : 
        begin
          AdcIntCalC[0]  =  1'b1;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_aLc;
        end
      dec_Plock : 
        begin
          iPllLockStartC =  1'b1;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_Plock;
        end
      dec_marker : 
        begin
          iBC0markC =  1'b1;
          nState1C =  dec_mwait;
        end
      dec_mwait : 
        begin
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_mwait;
        end
      dec_Ctp_1 : 
        begin
          TPcnt_rstC =  1'b0;
          TPcnt_cenC =  1'b1;
          iCatiaTPC =  1'b1;
          if (TPcnt_eocC==1'b1)
            nState1C =  dec_Ctp_2;
          else
            nState1C =  dec_Ctp_1;
        end
      dec_Ctp_2 : 
        begin
          TPcnt_rstC =  1'b0;
          TPcnt_cenC =  1'b0;
          iCatiaTPC =  1'b0;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_Ctp_2;
        end
      dec_wait : nState1C =  dec_idle;
      default : nState1C =  dec_idle;
    endcase
  end

always @( posedge clockA )
  begin
    if (rst_bA==0)
      begin
        cState0A =  rd_idle;
        cState1A =  dec_idle;
        InstrRegA =  4'b0000;
      end
    else
      begin
        cState0A =  nState0VotedA;
        cState1A =  nState1VotedA;
        if (IR_loadA==1)
          InstrRegA =  DecoderOutA;
      end
  end

always @( posedge clockB )
  begin
    if (rst_bB==0)
      begin
        cState0B =  rd_idle;
        cState1B =  dec_idle;
        InstrRegB =  4'b0000;
      end
    else
      begin
        cState0B =  nState0VotedB;
        cState1B =  nState1VotedB;
        if (IR_loadB==1)
          InstrRegB =  DecoderOutB;
      end
  end

always @( posedge clockC )
  begin
    if (rst_bC==0)
      begin
        cState0C =  rd_idle;
        cState1C =  dec_idle;
        InstrRegC =  4'b0000;
      end
    else
      begin
        cState0C =  nState0VotedC;
        cState1C =  nState1VotedC;
        if (IR_loadC==1)
          InstrRegC =  DecoderOutC;
      end
  end

always @( posedge clockA )
  begin
    if (rst_bA==0)
      #1 DtuSyncModeA =  1'b1;
    else
      #1 DtuSyncModeA =  nextSyncModeVotedA;
  end

always @( posedge clockB )
  begin
    if (rst_bB==0)
      #1 DtuSyncModeB =  1'b1;
    else
      #1 DtuSyncModeB =  nextSyncModeVotedB;
  end

always @( posedge clockC )
  begin
    if (rst_bC==0)
      #1 DtuSyncModeC =  1'b1;
    else
      #1 DtuSyncModeC =  nextSyncModeVotedC;
  end

always @( posedge clockA )
  begin
    if (rst_bA==0)
      #1 Flush_dlyA =  2'b00;
    else
      #1 Flush_dlyA =  {Flush_dlyA[0] ,iFlushA};
  end

always @( posedge clockB )
  begin
    if (rst_bB==0)
      #1 Flush_dlyB =  2'b00;
    else
      #1 Flush_dlyB =  {Flush_dlyB[0] ,iFlushB};
  end

always @( posedge clockC )
  begin
    if (rst_bC==0)
      #1 Flush_dlyC =  2'b00;
    else
      #1 Flush_dlyC =  {Flush_dlyC[0] ,iFlushC};
  end

always @( posedge clockA )
  begin
    if (cnt_rstA==1)
      counterA =  3'b000;
    else
      counterA =  counterA+1;
  end

always @( posedge clockB )
  begin
    if (cnt_rstB==1)
      counterB =  3'b000;
    else
      counterB =  counterB+1;
  end

always @( posedge clockC )
  begin
    if (cnt_rstC==1)
      counterC =  3'b000;
    else
      counterC =  counterC+1;
  end
assign cnt_eocA =  (counterA==3'b111) ? 1'b1 : 1'b0;
assign cnt_eocB =  (counterB==3'b111) ? 1'b1 : 1'b0;
assign cnt_eocC =  (counterC==3'b111) ? 1'b1 : 1'b0;

always @( posedge clockA )
  begin
    if (TPcnt_rstA==1'b1)
      TP_counterA =  10'h000;
    else
      if (TPcnt_cenA==1'b1)
        TP_counterA =  TP_counterA+1;
  end

always @( posedge clockB )
  begin
    if (TPcnt_rstB==1'b1)
      TP_counterB =  10'h000;
    else
      if (TPcnt_cenB==1'b1)
        TP_counterB =  TP_counterB+1;
  end

always @( posedge clockC )
  begin
    if (TPcnt_rstC==1'b1)
      TP_counterC =  10'h000;
    else
      if (TPcnt_cenC==1'b1)
        TP_counterC =  TP_counterC+1;
  end
assign TPcnt_eocA =  (TP_counterA=={TP_lenA,2'b11}) ? 1'b1 : 1'b0;
assign TPcnt_eocB =  (TP_counterB=={TP_lenB,2'b11}) ? 1'b1 : 1'b0;
assign TPcnt_eocC =  (TP_counterC=={TP_lenC,2'b11}) ? 1'b1 : 1'b0;

SU_mVoter rst_bVoter (
    .inA(rst_bA),
    .inB(rst_bB),
    .inC(rst_bC),
    .out(rst_b),
    .tmrErr(rst_bTmrError)
    );

SU_mVoter clockVoter (
    .inA(clockA),
    .inB(clockB),
    .inC(clockC),
    .out(clock),
    .tmrErr(clockTmrError)
    );

SU_mVoter int_TmrErrOutVoter (
    .inA(int_TmrErrOutA),
    .inB(int_TmrErrOutB),
    .inC(int_TmrErrOutC),
    .out(int_TmrErrOut),
    .tmrErr(int_TmrErrOutTmrError)
    );
assign tmrError =  clockTmrError|int_TmrErrOutTmrError|rst_bTmrError;

SU_mVoter #(.WIDTH(2)) nState0VoterA (
    .inA(nState0A),
    .inB(nState0B),
    .inC(nState0C),
    .out(nState0VotedA),
    .tmrErr(nState0TmrErrorA)
    );

SU_mVoter iPllLockStartVoterA (
    .inA(iPllLockStartA),
    .inB(iPllLockStartB),
    .inC(iPllLockStartC),
    .out(iPllLockStartVotedA),
    .tmrErr(iPllLockStartTmrErrorA)
    );

SU_mVoter #(.WIDTH(2)) iAdcRst_bVoterA (
    .inA(iAdcRst_bA),
    .inB(iAdcRst_bB),
    .inC(iAdcRst_bC),
    .out(iAdcRst_bVotedA),
    .tmrErr(iAdcRst_bTmrErrorA)
    );

SU_mVoter nextSyncModeVoterA (
    .inA(nextSyncModeA),
    .inB(nextSyncModeB),
    .inC(nextSyncModeC),
    .out(nextSyncModeVotedA),
    .tmrErr(nextSyncModeTmrErrorA)
    );

SU_mVoter iDtuRst_bVoterA (
    .inA(iDtuRst_bA),
    .inB(iDtuRst_bB),
    .inC(iDtuRst_bC),
    .out(iDtuRst_bVotedA),
    .tmrErr(iDtuRst_bTmrErrorA)
    );

SU_mVoter iFlushVoterA (
    .inA(iFlushA),
    .inB(iFlushB),
    .inC(iFlushC),
    .out(iFlushVotedA),
    .tmrErr(iFlushTmrErrorA)
    );

SU_mVoter iBC0markVoterA (
    .inA(iBC0markA),
    .inB(iBC0markB),
    .inC(iBC0markC),
    .out(iBC0markVotedA),
    .tmrErr(iBC0markTmrErrorA)
    );

SU_mVoter #(.WIDTH(5)) nState1VoterA (
    .inA(nState1A),
    .inB(nState1B),
    .inC(nState1C),
    .out(nState1VotedA),
    .tmrErr(nState1TmrErrorA)
    );

SU_mVoter iCatiaTPVoterA (
    .inA(iCatiaTPA),
    .inB(iCatiaTPB),
    .inC(iCatiaTPC),
    .out(iCatiaTPVotedA),
    .tmrErr(iCatiaTPTmrErrorA)
    );

SU_mVoter #(.WIDTH(2)) Flush_dlyVoterA (
    .inA(Flush_dlyA),
    .inB(Flush_dlyB),
    .inC(Flush_dlyC),
    .out(Flush_dlyVotedA),
    .tmrErr(Flush_dlyTmrErrorA)
    );

SU_mVoter iAtuRst_bVoterA (
    .inA(iAtuRst_bA),
    .inB(iAtuRst_bB),
    .inC(iAtuRst_bC),
    .out(iAtuRst_bVotedA),
    .tmrErr(iAtuRst_bTmrErrorA)
    );
assign tmrErrorA =  Flush_dlyTmrErrorA|iAdcRst_bTmrErrorA|iAtuRst_bTmrErrorA|iBC0markTmrErrorA|iCatiaTPTmrErrorA|iDtuRst_bTmrErrorA|iFlushTmrErrorA|iPllLockStartTmrErrorA|nState0TmrErrorA|nState1TmrErrorA|nextSyncModeTmrErrorA;

SU_mVoter #(.WIDTH(2)) iAdcRst_bVoterB (
    .inA(iAdcRst_bA),
    .inB(iAdcRst_bB),
    .inC(iAdcRst_bC),
    .out(iAdcRst_bVotedB),
    .tmrErr(iAdcRst_bTmrErrorB)
    );

SU_mVoter iPllLockStartVoterB (
    .inA(iPllLockStartA),
    .inB(iPllLockStartB),
    .inC(iPllLockStartC),
    .out(iPllLockStartVotedB),
    .tmrErr(iPllLockStartTmrErrorB)
    );

SU_mVoter #(.WIDTH(2)) nState0VoterB (
    .inA(nState0A),
    .inB(nState0B),
    .inC(nState0C),
    .out(nState0VotedB),
    .tmrErr(nState0TmrErrorB)
    );

SU_mVoter nextSyncModeVoterB (
    .inA(nextSyncModeA),
    .inB(nextSyncModeB),
    .inC(nextSyncModeC),
    .out(nextSyncModeVotedB),
    .tmrErr(nextSyncModeTmrErrorB)
    );

SU_mVoter iAtuRst_bVoterB (
    .inA(iAtuRst_bA),
    .inB(iAtuRst_bB),
    .inC(iAtuRst_bC),
    .out(iAtuRst_bVotedB),
    .tmrErr(iAtuRst_bTmrErrorB)
    );

SU_mVoter iFlushVoterB (
    .inA(iFlushA),
    .inB(iFlushB),
    .inC(iFlushC),
    .out(iFlushVotedB),
    .tmrErr(iFlushTmrErrorB)
    );

SU_mVoter iBC0markVoterB (
    .inA(iBC0markA),
    .inB(iBC0markB),
    .inC(iBC0markC),
    .out(iBC0markVotedB),
    .tmrErr(iBC0markTmrErrorB)
    );

SU_mVoter #(.WIDTH(2)) Flush_dlyVoterB (
    .inA(Flush_dlyA),
    .inB(Flush_dlyB),
    .inC(Flush_dlyC),
    .out(Flush_dlyVotedB),
    .tmrErr(Flush_dlyTmrErrorB)
    );

SU_mVoter #(.WIDTH(5)) nState1VoterB (
    .inA(nState1A),
    .inB(nState1B),
    .inC(nState1C),
    .out(nState1VotedB),
    .tmrErr(nState1TmrErrorB)
    );

SU_mVoter iDtuRst_bVoterB (
    .inA(iDtuRst_bA),
    .inB(iDtuRst_bB),
    .inC(iDtuRst_bC),
    .out(iDtuRst_bVotedB),
    .tmrErr(iDtuRst_bTmrErrorB)
    );

SU_mVoter iCatiaTPVoterB (
    .inA(iCatiaTPA),
    .inB(iCatiaTPB),
    .inC(iCatiaTPC),
    .out(iCatiaTPVotedB),
    .tmrErr(iCatiaTPTmrErrorB)
    );
assign tmrErrorB =  Flush_dlyTmrErrorB|iAdcRst_bTmrErrorB|iAtuRst_bTmrErrorB|iBC0markTmrErrorB|iCatiaTPTmrErrorB|iDtuRst_bTmrErrorB|iFlushTmrErrorB|iPllLockStartTmrErrorB|nState0TmrErrorB|nState1TmrErrorB|nextSyncModeTmrErrorB;

SU_mVoter iPllLockStartVoterC (
    .inA(iPllLockStartA),
    .inB(iPllLockStartB),
    .inC(iPllLockStartC),
    .out(iPllLockStartVotedC),
    .tmrErr(iPllLockStartTmrErrorC)
    );

SU_mVoter #(.WIDTH(2)) iAdcRst_bVoterC (
    .inA(iAdcRst_bA),
    .inB(iAdcRst_bB),
    .inC(iAdcRst_bC),
    .out(iAdcRst_bVotedC),
    .tmrErr(iAdcRst_bTmrErrorC)
    );

SU_mVoter #(.WIDTH(2)) nState0VoterC (
    .inA(nState0A),
    .inB(nState0B),
    .inC(nState0C),
    .out(nState0VotedC),
    .tmrErr(nState0TmrErrorC)
    );

SU_mVoter iDtuRst_bVoterC (
    .inA(iDtuRst_bA),
    .inB(iDtuRst_bB),
    .inC(iDtuRst_bC),
    .out(iDtuRst_bVotedC),
    .tmrErr(iDtuRst_bTmrErrorC)
    );

SU_mVoter iAtuRst_bVoterC (
    .inA(iAtuRst_bA),
    .inB(iAtuRst_bB),
    .inC(iAtuRst_bC),
    .out(iAtuRst_bVotedC),
    .tmrErr(iAtuRst_bTmrErrorC)
    );

SU_mVoter iBC0markVoterC (
    .inA(iBC0markA),
    .inB(iBC0markB),
    .inC(iBC0markC),
    .out(iBC0markVotedC),
    .tmrErr(iBC0markTmrErrorC)
    );

SU_mVoter nextSyncModeVoterC (
    .inA(nextSyncModeA),
    .inB(nextSyncModeB),
    .inC(nextSyncModeC),
    .out(nextSyncModeVotedC),
    .tmrErr(nextSyncModeTmrErrorC)
    );

SU_mVoter #(.WIDTH(5)) nState1VoterC (
    .inA(nState1A),
    .inB(nState1B),
    .inC(nState1C),
    .out(nState1VotedC),
    .tmrErr(nState1TmrErrorC)
    );

SU_mVoter iFlushVoterC (
    .inA(iFlushA),
    .inB(iFlushB),
    .inC(iFlushC),
    .out(iFlushVotedC),
    .tmrErr(iFlushTmrErrorC)
    );

SU_mVoter #(.WIDTH(2)) Flush_dlyVoterC (
    .inA(Flush_dlyA),
    .inB(Flush_dlyB),
    .inC(Flush_dlyC),
    .out(Flush_dlyVotedC),
    .tmrErr(Flush_dlyTmrErrorC)
    );

SU_mVoter iCatiaTPVoterC (
    .inA(iCatiaTPA),
    .inB(iCatiaTPB),
    .inC(iCatiaTPC),
    .out(iCatiaTPVotedC),
    .tmrErr(iCatiaTPTmrErrorC)
    );
assign tmrErrorC =  Flush_dlyTmrErrorC|iAdcRst_bTmrErrorC|iAtuRst_bTmrErrorC|iBC0markTmrErrorC|iCatiaTPTmrErrorC|iDtuRst_bTmrErrorC|iFlushTmrErrorC|iPllLockStartTmrErrorC|nState0TmrErrorC|nState1TmrErrorC|nextSyncModeTmrErrorC;

SU_fout #(.WIDTH(2)) TmrErrInFanout (
    .in(TmrErrIn),
    .outA(TmrErrInA),
    .outB(TmrErrInB),
    .outC(TmrErrInC)
    );

SU_fout #(.WIDTH(8)) TP_lenFanout (
    .in(TP_len),
    .outA(TP_lenA),
    .outB(TP_lenB),
    .outC(TP_lenC)
    );
endmodule

module HammingDecoder4TMR #(
  parameter NBits=4,
  parameter NBitsEnc=8
)(
  input [NBitsEnc-1:0] data_encA,
  input [NBitsEnc-1:0] data_encB,
  input [NBitsEnc-1:0] data_encC,
  output [NBits-1:0] data_outA,
  output [NBits-1:0] data_outB,
  output [NBits-1:0] data_outC,
  output  SEU_errorA,
  output  SEU_errorB,
  output  SEU_errorC
);
wire [NBitsEnc-NBits-1:0] parity_outA;
wire [NBitsEnc-NBits-1:0] parity_outB;
wire [NBitsEnc-NBits-1:0] parity_outC;
reg  [NBitsEnc-1:0] correctionA;
reg  [NBitsEnc-1:0] correctionB;
reg  [NBitsEnc-1:0] correctionC;
assign data_outA[0]  =  data_encA[2] ^correctionA[2] ;
assign data_outB[0]  =  data_encB[2] ^correctionB[2] ;
assign data_outC[0]  =  data_encC[2] ^correctionC[2] ;
assign data_outA[3:1]  =  data_encA[6:4] ^correctionA[6:4] ;
assign data_outB[3:1]  =  data_encB[6:4] ^correctionB[6:4] ;
assign data_outC[3:1]  =  data_encC[6:4] ^correctionC[6:4] ;
assign parity_outA[0]  =  data_encA[0] ^data_encA[2] ^data_encA[4] ^data_encA[6] ;
assign parity_outB[0]  =  data_encB[0] ^data_encB[2] ^data_encB[4] ^data_encB[6] ;
assign parity_outC[0]  =  data_encC[0] ^data_encC[2] ^data_encC[4] ^data_encC[6] ;
assign parity_outA[1]  =  data_encA[1] ^data_encA[2] ^data_encA[5] ^data_encA[6] ;
assign parity_outB[1]  =  data_encB[1] ^data_encB[2] ^data_encB[5] ^data_encB[6] ;
assign parity_outC[1]  =  data_encC[1] ^data_encC[2] ^data_encC[5] ^data_encC[6] ;
assign parity_outA[2]  =  data_encA[3] ^data_encA[4] ^data_encA[5] ^data_encA[6] ;
assign parity_outB[2]  =  data_encB[3] ^data_encB[4] ^data_encB[5] ^data_encB[6] ;
assign parity_outC[2]  =  data_encC[3] ^data_encC[4] ^data_encC[5] ^data_encC[6] ;
assign parity_outA[3]  =  data_encA[7] ;
assign parity_outB[3]  =  data_encB[7] ;
assign parity_outC[3]  =  data_encC[7] ;
assign SEU_errorA =  parity_outA[3] |parity_outA[2] |parity_outA[1] |parity_outA[0] ;
assign SEU_errorB =  parity_outB[3] |parity_outB[2] |parity_outB[1] |parity_outB[0] ;
assign SEU_errorC =  parity_outC[3] |parity_outC[2] |parity_outC[1] |parity_outC[0] ;

always @( parity_outA )
  begin
    case (parity_outA)
      4'b0000 : correctionA =  8'b00000000;
      4'b0001 : correctionA =  8'b00000001;
      4'b0010 : correctionA =  8'b00000010;
      4'b0011 : correctionA =  8'b00000100;
      4'b0100 : correctionA =  8'b00001000;
      4'b0101 : correctionA =  8'b00010000;
      4'b0110 : correctionA =  8'b00100000;
      4'b0111 : correctionA =  8'b01000000;
      4'b1000 : correctionA =  8'b10000000;
      default : correctionA =  8'b00000000;
    endcase
  end

always @( parity_outB )
  begin
    case (parity_outB)
      4'b0000 : correctionB =  8'b00000000;
      4'b0001 : correctionB =  8'b00000001;
      4'b0010 : correctionB =  8'b00000010;
      4'b0011 : correctionB =  8'b00000100;
      4'b0100 : correctionB =  8'b00001000;
      4'b0101 : correctionB =  8'b00010000;
      4'b0110 : correctionB =  8'b00100000;
      4'b0111 : correctionB =  8'b01000000;
      4'b1000 : correctionB =  8'b10000000;
      default : correctionB =  8'b00000000;
    endcase
  end

always @( parity_outC )
  begin
    case (parity_outC)
      4'b0000 : correctionC =  8'b00000000;
      4'b0001 : correctionC =  8'b00000001;
      4'b0010 : correctionC =  8'b00000010;
      4'b0011 : correctionC =  8'b00000100;
      4'b0100 : correctionC =  8'b00001000;
      4'b0101 : correctionC =  8'b00010000;
      4'b0110 : correctionC =  8'b00100000;
      4'b0111 : correctionC =  8'b01000000;
      4'b1000 : correctionC =  8'b10000000;
      default : correctionC =  8'b00000000;
    endcase
  end
endmodule



// /export/elt153xl/disk0/users/gianni/projects/LiTE-DTU/tmrg/src/../common/voter.v
module SU_mVoter (inA, inB, inC, out, tmrErr);
  parameter WIDTH = 1;
  input   [(WIDTH-1):0]   inA, inB, inC;
  output  [(WIDTH-1):0]   out;
  output                  tmrErr;
  reg                     tmrErr;
  assign out = (inA&inB) | (inA&inC) | (inB&inC);
  always @(inA or inB or inC)
  begin
    if (inA!=inB || inA!=inC || inB!=inC)
      tmrErr = 1;
    else
      tmrErr = 0;
  end
endmodule


// /export/elt153xl/disk0/users/gianni/projects/LiTE-DTU/tmrg/src/../common/SU_fout.v
module SU_fout (in, outA, outB, outC);
  parameter WIDTH = 1;
  input   [(WIDTH-1):0]   in;
  output  [(WIDTH-1):0]   outA,outB,outC;
  assign outA=in;
  assign outB=in;
  assign outC=in;
endmodule
