/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./SyncUnit_v2TMR.v                                                                     *
 *                                                                                                  *
 * user    : gianni                                                                                 *
 * host    : elt153xl.to.infn.it                                                                    *
 * date    : 21/12/2020 11:10:19                                                                    *
 *                                                                                                  *
 * workdir : /export/elt153xl/disk0/users/gianni/projects/LiTE-DTU/v2/netlist_in                    *
 * cmd     : /export/elt153xl/disk0/users/gianni/projects/LiTE-DTU/tmrg/bin/tmrg --sdc-generate --sdc- *
 *           headers --config SyncUnit_v2.cfg SyncUnit_v2.v                                         *
 * tmrg rev: 9a6ee4d64fce05b58c62ee9ecfc4ef5a8551d404                                               *
 *                                                                                                  *
 * src file: SyncUnit_v2.v                                                                          *
 *           File is NOT under version control!                                                     *
 *           Modification time : 2020-12-21 11:10:14.910669                                         *
 *           File Size         : 10790                                                              *
 *           MD5 hash          : b979a6ac1e4ab94e7baf8a5202c707e6                                   *
 *                                                                                                  *
 ****************************************************************************************************/
`timescale  1ps/1ps

module SyncUnit_v2TMR #(
  parameter NBitsEnc=8,
  parameter NBits=4
)(
  input  rst_bA,
  input  rst_bB,
  input  rst_bC,
  input  clockA,
  input  clockB,
  input  clockC,
  input  serial_inA,
  input  serial_inB,
  input  serial_inC,
  output reg  DtuRst_bA,
  output reg  DtuRst_bB,
  output reg  DtuRst_bC,
  output  i2cRst_bA,
  output  i2cRst_bB,
  output  i2cRst_bC,
  output reg  atuRst_bA,
  output reg  atuRst_bB,
  output reg  atuRst_bC,
  output reg  DtuSyncModeA,
  output reg  DtuSyncModeB,
  output reg  DtuSyncModeC,
  output  DtuFlushA,
  output  DtuFlushB,
  output  DtuFlushC,
  output reg [1:0] AdcRst_bA,
  output reg [1:0] AdcRst_bB,
  output reg [1:0] AdcRst_bC,
  output [1:0] AdcCalA,
  output [1:0] AdcCalB,
  output [1:0] AdcCalC,
  output reg  PllLockStartA,
  output reg  PllLockStartB,
  output reg  PllLockStartC,
  output reg  CatiaTPA,
  output reg  CatiaTPB,
  output reg  CatiaTPC,
  output reg  BC0markA,
  output reg  BC0markB,
  output reg  BC0markC,
  input [7:0] TP_len,
  input [1:0] AdcCalBusyIn,
  input [1:0] AdcOvfIn,
  input [1:0] AdcSeuIn,
  output  AdcCalBusyOut,
  output  AdcOvfOut,
  output  AdcSeuOut,
  input [4:0] TmrErrIn,
  output reg  TmrErrOut
);
localparam    rd_idle=2'b00;
localparam    rd_load=2'b01;
localparam    rd_wait=2'b11;
localparam    dec_idle=4'b0000;
localparam    dec_aHr=4'b0001;
localparam    dec_aLr=4'b0010;
localparam    dec_DTUr=4'b0011;
localparam    dec_I2Cr=4'b0100;
localparam    dec_ATUr=4'b0101;
localparam    dec_aHc=4'b0110;
localparam    dec_aLc=4'b0111;
localparam    dec_DTUs=4'b1000;
localparam    dec_DTUn=4'b1001;
localparam    dec_Plock=4'b1010;
localparam    dec_marker=4'b1011;
localparam    dec_Ctp_1=4'b1100;
localparam    dec_Ctp_2=4'b1101;
localparam    dec_DTUf=4'b1110;
localparam    dec_wait=4'b1111;
localparam    start=8'b00000111;
localparam    stop=8'b00000000;
localparam    dtu_rst=4'b0010;
localparam    i2c_rst=4'b0011;
localparam    dtu_sm=4'b0101;
localparam    dtu_nm=4'b0110;
localparam    dtu_fl=4'b0111;
localparam    atu_rst=4'b0100;
localparam    adcH_rst=4'b1000;
localparam    adcH_cal=4'b1001;
localparam    adcL_rst=4'b1010;
localparam    adcL_cal=4'b1011;
localparam    pll_lock=4'b1100;
localparam    catia_tp=4'b1101;
localparam    bc0_mark=4'b1110;
wire [7:0] TP_lenC;
wire [7:0] TP_lenB;
wire [7:0] TP_lenA;
wire [4:0] TmrErrInC;
wire [4:0] TmrErrInB;
wire [4:0] TmrErrInA;
wor nState0TmrErrorC;
wire [1:0] nState0VotedC;
wor nState1TmrErrorC;
wire [3:0] nState1VotedC;
wor nState1TmrErrorB;
wire [3:0] nState1VotedB;
wor nState0TmrErrorB;
wire [1:0] nState0VotedB;
wor nState0TmrErrorA;
wire [1:0] nState0VotedA;
wor nState1TmrErrorA;
wire [3:0] nState1VotedA;
wor int_TmrErrOutTmrError;
wire int_TmrErrOut;
wor clockTmrError;
wire clock;
wor rst_bTmrError;
wire rst_b;
reg  [NBitsEnc:0] ShiftRegisterA;
reg  [NBitsEnc:0] ShiftRegisterB;
reg  [NBitsEnc:0] ShiftRegisterC;
wire [NBits-1:0] DecoderOutA;
wire [NBits-1:0] DecoderOutB;
wire [NBits-1:0] DecoderOutC;
reg  [NBits-1:0] InstrRegA;
reg  [NBits-1:0] InstrRegB;
reg  [NBits-1:0] InstrRegC;
reg  IR_loadA;
reg  IR_loadB;
reg  IR_loadC;
reg  [9:0] TP_counterA;
reg  [9:0] TP_counterB;
reg  [9:0] TP_counterC;
reg  TPcnt_rstA;
reg  TPcnt_rstB;
reg  TPcnt_rstC;
reg  TPcnt_cenA;
reg  TPcnt_cenB;
reg  TPcnt_cenC;
wire TPcnt_eocA;
wire TPcnt_eocB;
wire TPcnt_eocC;
wire int_TmrErrOutA;
wire int_TmrErrOutB;
wire int_TmrErrOutC;
reg  [1:0] AdcIntCalA;
reg  [1:0] AdcIntCalB;
reg  [1:0] AdcIntCalC;
reg  nextDtuSyncModeA;
reg  nextDtuSyncModeB;
reg  nextDtuSyncModeC;
reg  [1:0] cState0A;
reg  [1:0] cState0B;
reg  [1:0] cState0C;
reg  [1:0] nState0A;
reg  [1:0] nState0B;
reg  [1:0] nState0C;
reg  [3:0] cState1A;
reg  [3:0] cState1B;
reg  [3:0] cState1C;
reg  [3:0] nState1A;
reg  [3:0] nState1B;
reg  [3:0] nState1C;
reg  [2:0] counterA;
reg  [2:0] counterB;
reg  [2:0] counterC;
reg  cnt_rstA;
reg  cnt_rstB;
reg  cnt_rstC;
wire cnt_eocA;
wire cnt_eocB;
wire cnt_eocC;
reg  int_i2cRst_bA;
reg  int_i2cRst_bB;
reg  int_i2cRst_bC;
reg  int_DtuFlushA;
reg  int_DtuFlushB;
reg  int_DtuFlushC;
reg  [1:0] DtuFlush_dlyA;
reg  [1:0] DtuFlush_dlyB;
reg  [1:0] DtuFlush_dlyC;
wire asynch_i2cRst_bA;
wire asynch_i2cRst_bB;
wire asynch_i2cRst_bC;
wire encoding_errorA;
wire encoding_errorB;
wire encoding_errorC;

	deglitch rstA_deglitch (.A(rst_bA), .Z(asynch_i2cRst_bA));
	deglitch rstB_deglitch (.A(rst_bB), .Z(asynch_i2cRst_bB));
	deglitch rstC_deglitch (.A(rst_bC), .Z(asynch_i2cRst_bC));

assign i2cRst_bA =  int_i2cRst_bA&asynch_i2cRst_bA;
assign i2cRst_bB =  int_i2cRst_bB&asynch_i2cRst_bB;
assign i2cRst_bC =  int_i2cRst_bC&asynch_i2cRst_bC;
assign AdcCalBusyOut =  AdcCalBusyIn[1] |AdcCalBusyIn[0] ;
assign AdcOvfOut =  AdcOvfIn[1] |AdcOvfIn[0] ;
assign AdcSeuOut =  AdcSeuIn[1] |AdcSeuIn[0] ;
assign int_TmrErrOutA =  TmrErrInA[4] |TmrErrInA[3] |TmrErrInA[2] |TmrErrInA[1] |TmrErrInA[0] ;
assign int_TmrErrOutB =  TmrErrInB[4] |TmrErrInB[3] |TmrErrInB[2] |TmrErrInB[1] |TmrErrInB[0] ;
assign int_TmrErrOutC =  TmrErrInC[4] |TmrErrInC[3] |TmrErrInC[2] |TmrErrInC[1] |TmrErrInC[0] ;

always @( posedge clock )
  begin
    if (rst_b==0)
      TmrErrOut =  1'b0;
    else
      TmrErrOut =  int_TmrErrOut;
  end

always @( posedge clockA )
  begin
    if (rst_bA==0)
      ShiftRegisterA <= 'h0;
    else
      ShiftRegisterA <= {ShiftRegisterA[NBitsEnc-1:0] ,serial_inA};
  end

always @( posedge clockB )
  begin
    if (rst_bB==0)
      ShiftRegisterB <= 'h0;
    else
      ShiftRegisterB <= {ShiftRegisterB[NBitsEnc-1:0] ,serial_inB};
  end

always @( posedge clockC )
  begin
    if (rst_bC==0)
      ShiftRegisterC <= 'h0;
    else
      ShiftRegisterC <= {ShiftRegisterC[NBitsEnc-1:0] ,serial_inC};
  end

HammingDecoder4TMR #(.NBits(NBits), .NBitsEnc(NBitsEnc)) I_Decoder (
    .data_encA(ShiftRegisterA[NBitsEnc:1] ),
    .data_encB(ShiftRegisterB[NBitsEnc:1] ),
    .data_encC(ShiftRegisterC[NBitsEnc:1] ),
    .data_outA(DecoderOutA),
    .data_outB(DecoderOutB),
    .data_outC(DecoderOutC),
    .SEU_errorA(encoding_errorA),
    .SEU_errorB(encoding_errorB),
    .SEU_errorC(encoding_errorC)
    );

always @( cState0A or ShiftRegisterA or cnt_eocA )
  begin
    cnt_rstA =  1'b1;
    IR_loadA =  1'b0;
    case (cState0A)
      rd_idle : 
        begin
          if (ShiftRegisterA[NBitsEnc-1:0] ==start)
            nState0A =  rd_load;
          else
            nState0A =  rd_idle;
        end
      rd_load : 
        begin
          cnt_rstA =  1'b0;
          IR_loadA =  1'b1;
          if (ShiftRegisterA[NBitsEnc-1:0] ==stop)
            nState0A =  rd_idle;
          else
            nState0A =  rd_wait;
        end
      rd_wait : 
        begin
          cnt_rstA =  1'b0;
          if (cnt_eocA==0)
            nState0A =  rd_wait;
          else
            nState0A =  rd_load;
        end
      default : nState0A =  rd_idle;
    endcase
  end

always @( cState0B or ShiftRegisterB or cnt_eocB )
  begin
    cnt_rstB =  1'b1;
    IR_loadB =  1'b0;
    case (cState0B)
      rd_idle : 
        begin
          if (ShiftRegisterB[NBitsEnc-1:0] ==start)
            nState0B =  rd_load;
          else
            nState0B =  rd_idle;
        end
      rd_load : 
        begin
          cnt_rstB =  1'b0;
          IR_loadB =  1'b1;
          if (ShiftRegisterB[NBitsEnc-1:0] ==stop)
            nState0B =  rd_idle;
          else
            nState0B =  rd_wait;
        end
      rd_wait : 
        begin
          cnt_rstB =  1'b0;
          if (cnt_eocB==0)
            nState0B =  rd_wait;
          else
            nState0B =  rd_load;
        end
      default : nState0B =  rd_idle;
    endcase
  end

always @( cState0C or ShiftRegisterC or cnt_eocC )
  begin
    cnt_rstC =  1'b1;
    IR_loadC =  1'b0;
    case (cState0C)
      rd_idle : 
        begin
          if (ShiftRegisterC[NBitsEnc-1:0] ==start)
            nState0C =  rd_load;
          else
            nState0C =  rd_idle;
        end
      rd_load : 
        begin
          cnt_rstC =  1'b0;
          IR_loadC =  1'b1;
          if (ShiftRegisterC[NBitsEnc-1:0] ==stop)
            nState0C =  rd_idle;
          else
            nState0C =  rd_wait;
        end
      rd_wait : 
        begin
          cnt_rstC =  1'b0;
          if (cnt_eocC==0)
            nState0C =  rd_wait;
          else
            nState0C =  rd_load;
        end
      default : nState0C =  rd_idle;
    endcase
  end
assign AdcCalA[0]  =  AdcIntCalA[0] ;
assign AdcCalB[0]  =  AdcIntCalB[0] ;
assign AdcCalC[0]  =  AdcIntCalC[0] ;
assign AdcCalA[1]  =  AdcIntCalA[1] ;
assign AdcCalB[1]  =  AdcIntCalB[1] ;
assign AdcCalC[1]  =  AdcIntCalC[1] ;

always @( cState0A or cState1A or InstrRegA or cnt_eocA or TPcnt_eocA )
  begin
    AdcRst_bA =  2'b11;
    AdcIntCalA =  2'b00;
    DtuRst_bA =  1'b1;
    int_i2cRst_bA =  1'b1;
    atuRst_bA =  1'b1;
    nextDtuSyncModeA =  DtuSyncModeA;
    #1 int_DtuFlushA =  1'b0;
    PllLockStartA =  1'b0;
    CatiaTPA =  1'b0;
    BC0markA =  1'b0;
    TPcnt_rstA =  1'b1;
    TPcnt_cenA =  1'b0;
    case (cState1A)
      dec_idle : 
        begin
          case (InstrRegA)
            dtu_rst : nState1A =  dec_DTUr;
            i2c_rst : nState1A =  dec_I2Cr;
            dtu_sm : nState1A =  dec_DTUs;
            dtu_nm : nState1A =  dec_DTUn;
            atu_rst : nState1A =  dec_ATUr;
            dtu_fl : nState1A =  dec_DTUf;
            adcH_rst : nState1A =  dec_aHr;
            adcL_rst : nState1A =  dec_aLr;
            adcH_cal : nState1A =  dec_aHc;
            adcL_cal : nState1A =  dec_aLc;
            pll_lock : nState1A =  dec_Plock;
            catia_tp : nState1A =  dec_Ctp_1;
            bc0_mark : nState1A =  dec_marker;
            default : nState1A =  dec_idle;
          endcase
        end
      dec_DTUr : 
        begin
          DtuRst_bA =  1'b0;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_DTUr;
        end
      dec_I2Cr : 
        begin
          int_i2cRst_bA =  1'b0;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_I2Cr;
        end
      dec_DTUs : 
        begin
          nextDtuSyncModeA =  1'b1;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_DTUs;
        end
      dec_DTUn : 
        begin
          nextDtuSyncModeA =  1'b0;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_DTUn;
        end
      dec_DTUf : 
        begin
          #1 int_DtuFlushA =  1'b1;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_DTUf;
        end
      dec_I2Cr : 
        begin
          int_i2cRst_bA =  1'b0;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_I2Cr;
        end
      dec_ATUr : 
        begin
          atuRst_bA =  1'b0;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_ATUr;
        end
      dec_aHr : 
        begin
          AdcRst_bA[1]  =  1'b0;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_aHr;
        end
      dec_aLr : 
        begin
          AdcRst_bA[0]  =  1'b0;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_aLr;
        end
      dec_aHc : 
        begin
          AdcIntCalA[1]  =  1'b1;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_aHc;
        end
      dec_aLc : 
        begin
          AdcIntCalA[0]  =  1'b1;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_aLc;
        end
      dec_Plock : 
        begin
          PllLockStartA =  1'b1;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_Plock;
        end
      dec_marker : 
        begin
          BC0markA =  1'b1;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_marker;
        end
      dec_Ctp_1 : 
        begin
          TPcnt_rstA =  1'b0;
          TPcnt_cenA =  1'b1;
          CatiaTPA =  1'b1;
          if (TPcnt_eocA==1'b1)
            nState1A =  dec_Ctp_2;
          else
            nState1A =  dec_Ctp_1;
        end
      dec_Ctp_2 : 
        begin
          TPcnt_rstA =  1'b0;
          TPcnt_cenA =  1'b0;
          CatiaTPA =  1'b0;
          if ((cnt_eocA==1)|(cState0A==rd_idle))
            nState1A =  dec_wait;
          else
            nState1A =  dec_Ctp_2;
        end
      dec_wait : nState1A =  dec_idle;
      default : nState1A =  dec_idle;
    endcase
  end

always @( cState0B or cState1B or InstrRegB or cnt_eocB or TPcnt_eocB )
  begin
    AdcRst_bB =  2'b11;
    AdcIntCalB =  2'b00;
    DtuRst_bB =  1'b1;
    int_i2cRst_bB =  1'b1;
    atuRst_bB =  1'b1;
    nextDtuSyncModeB =  DtuSyncModeB;
    #1 int_DtuFlushB =  1'b0;
    PllLockStartB =  1'b0;
    CatiaTPB =  1'b0;
    BC0markB =  1'b0;
    TPcnt_rstB =  1'b1;
    TPcnt_cenB =  1'b0;
    case (cState1B)
      dec_idle : 
        begin
          case (InstrRegB)
            dtu_rst : nState1B =  dec_DTUr;
            i2c_rst : nState1B =  dec_I2Cr;
            dtu_sm : nState1B =  dec_DTUs;
            dtu_nm : nState1B =  dec_DTUn;
            atu_rst : nState1B =  dec_ATUr;
            dtu_fl : nState1B =  dec_DTUf;
            adcH_rst : nState1B =  dec_aHr;
            adcL_rst : nState1B =  dec_aLr;
            adcH_cal : nState1B =  dec_aHc;
            adcL_cal : nState1B =  dec_aLc;
            pll_lock : nState1B =  dec_Plock;
            catia_tp : nState1B =  dec_Ctp_1;
            bc0_mark : nState1B =  dec_marker;
            default : nState1B =  dec_idle;
          endcase
        end
      dec_DTUr : 
        begin
          DtuRst_bB =  1'b0;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_DTUr;
        end
      dec_I2Cr : 
        begin
          int_i2cRst_bB =  1'b0;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_I2Cr;
        end
      dec_DTUs : 
        begin
          nextDtuSyncModeB =  1'b1;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_DTUs;
        end
      dec_DTUn : 
        begin
          nextDtuSyncModeB =  1'b0;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_DTUn;
        end
      dec_DTUf : 
        begin
          #1 int_DtuFlushB =  1'b1;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_DTUf;
        end
      dec_I2Cr : 
        begin
          int_i2cRst_bB =  1'b0;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_I2Cr;
        end
      dec_ATUr : 
        begin
          atuRst_bB =  1'b0;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_ATUr;
        end
      dec_aHr : 
        begin
          AdcRst_bB[1]  =  1'b0;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_aHr;
        end
      dec_aLr : 
        begin
          AdcRst_bB[0]  =  1'b0;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_aLr;
        end
      dec_aHc : 
        begin
          AdcIntCalB[1]  =  1'b1;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_aHc;
        end
      dec_aLc : 
        begin
          AdcIntCalB[0]  =  1'b1;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_aLc;
        end
      dec_Plock : 
        begin
          PllLockStartB =  1'b1;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_Plock;
        end
      dec_marker : 
        begin
          BC0markB =  1'b1;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_marker;
        end
      dec_Ctp_1 : 
        begin
          TPcnt_rstB =  1'b0;
          TPcnt_cenB =  1'b1;
          CatiaTPB =  1'b1;
          if (TPcnt_eocB==1'b1)
            nState1B =  dec_Ctp_2;
          else
            nState1B =  dec_Ctp_1;
        end
      dec_Ctp_2 : 
        begin
          TPcnt_rstB =  1'b0;
          TPcnt_cenB =  1'b0;
          CatiaTPB =  1'b0;
          if ((cnt_eocB==1)|(cState0B==rd_idle))
            nState1B =  dec_wait;
          else
            nState1B =  dec_Ctp_2;
        end
      dec_wait : nState1B =  dec_idle;
      default : nState1B =  dec_idle;
    endcase
  end

always @( cState0C or cState1C or InstrRegC or cnt_eocC or TPcnt_eocC )
  begin
    AdcRst_bC =  2'b11;
    AdcIntCalC =  2'b00;
    DtuRst_bC =  1'b1;
    int_i2cRst_bC =  1'b1;
    atuRst_bC =  1'b1;
    nextDtuSyncModeC =  DtuSyncModeC;
    #1 int_DtuFlushC =  1'b0;
    PllLockStartC =  1'b0;
    CatiaTPC =  1'b0;
    BC0markC =  1'b0;
    TPcnt_rstC =  1'b1;
    TPcnt_cenC =  1'b0;
    case (cState1C)
      dec_idle : 
        begin
          case (InstrRegC)
            dtu_rst : nState1C =  dec_DTUr;
            i2c_rst : nState1C =  dec_I2Cr;
            dtu_sm : nState1C =  dec_DTUs;
            dtu_nm : nState1C =  dec_DTUn;
            atu_rst : nState1C =  dec_ATUr;
            dtu_fl : nState1C =  dec_DTUf;
            adcH_rst : nState1C =  dec_aHr;
            adcL_rst : nState1C =  dec_aLr;
            adcH_cal : nState1C =  dec_aHc;
            adcL_cal : nState1C =  dec_aLc;
            pll_lock : nState1C =  dec_Plock;
            catia_tp : nState1C =  dec_Ctp_1;
            bc0_mark : nState1C =  dec_marker;
            default : nState1C =  dec_idle;
          endcase
        end
      dec_DTUr : 
        begin
          DtuRst_bC =  1'b0;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_DTUr;
        end
      dec_I2Cr : 
        begin
          int_i2cRst_bC =  1'b0;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_I2Cr;
        end
      dec_DTUs : 
        begin
          nextDtuSyncModeC =  1'b1;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_DTUs;
        end
      dec_DTUn : 
        begin
          nextDtuSyncModeC =  1'b0;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_DTUn;
        end
      dec_DTUf : 
        begin
          #1 int_DtuFlushC =  1'b1;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_DTUf;
        end
      dec_I2Cr : 
        begin
          int_i2cRst_bC =  1'b0;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_I2Cr;
        end
      dec_ATUr : 
        begin
          atuRst_bC =  1'b0;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_ATUr;
        end
      dec_aHr : 
        begin
          AdcRst_bC[1]  =  1'b0;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_aHr;
        end
      dec_aLr : 
        begin
          AdcRst_bC[0]  =  1'b0;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_aLr;
        end
      dec_aHc : 
        begin
          AdcIntCalC[1]  =  1'b1;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_aHc;
        end
      dec_aLc : 
        begin
          AdcIntCalC[0]  =  1'b1;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_aLc;
        end
      dec_Plock : 
        begin
          PllLockStartC =  1'b1;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_Plock;
        end
      dec_marker : 
        begin
          BC0markC =  1'b1;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_marker;
        end
      dec_Ctp_1 : 
        begin
          TPcnt_rstC =  1'b0;
          TPcnt_cenC =  1'b1;
          CatiaTPC =  1'b1;
          if (TPcnt_eocC==1'b1)
            nState1C =  dec_Ctp_2;
          else
            nState1C =  dec_Ctp_1;
        end
      dec_Ctp_2 : 
        begin
          TPcnt_rstC =  1'b0;
          TPcnt_cenC =  1'b0;
          CatiaTPC =  1'b0;
          if ((cnt_eocC==1)|(cState0C==rd_idle))
            nState1C =  dec_wait;
          else
            nState1C =  dec_Ctp_2;
        end
      dec_wait : nState1C =  dec_idle;
      default : nState1C =  dec_idle;
    endcase
  end

always @( posedge clockA )
  begin
    if (rst_bA==0)
      begin
        cState0A =  rd_idle;
        cState1A =  dec_idle;
        InstrRegA =  4'b0000;
      end
    else
      begin
        cState0A =  nState0A;
        cState1A =  nState1A;
        if (IR_loadA==1)
          InstrRegA =  DecoderOutA;
      end
  end

always @( posedge clockB )
  begin
    if (rst_bB==0)
      begin
        cState0B =  rd_idle;
        cState1B =  dec_idle;
        InstrRegB =  4'b0000;
      end
    else
      begin
        cState0B =  nState0B;
        cState1B =  nState1B;
        if (IR_loadB==1)
          InstrRegB =  DecoderOutB;
      end
  end

always @( posedge clockC )
  begin
    if (rst_bC==0)
      begin
        cState0C =  rd_idle;
        cState1C =  dec_idle;
        InstrRegC =  4'b0000;
      end
    else
      begin
        cState0C =  nState0C;
        cState1C =  nState1C;
        if (IR_loadC==1)
          InstrRegC =  DecoderOutC;
      end
  end

always @( posedge clockA )
  begin
    if (rst_bA==0)
      #1 DtuSyncModeA =  1'b1;
    else
      #1 DtuSyncModeA =  nextDtuSyncModeA;
  end

always @( posedge clockB )
  begin
    if (rst_bB==0)
      #1 DtuSyncModeB =  1'b1;
    else
      #1 DtuSyncModeB =  nextDtuSyncModeB;
  end

always @( posedge clockC )
  begin
    if (rst_bC==0)
      #1 DtuSyncModeC =  1'b1;
    else
      #1 DtuSyncModeC =  nextDtuSyncModeC;
  end

always @( posedge clockA )
  begin
    if (rst_bA==0)
      #1 DtuFlush_dlyA =  2'b00;
    else
      #1 DtuFlush_dlyA =  {DtuFlush_dlyA[0] ,int_DtuFlushA};
  end

always @( posedge clockB )
  begin
    if (rst_bB==0)
      #1 DtuFlush_dlyB =  2'b00;
    else
      #1 DtuFlush_dlyB =  {DtuFlush_dlyB[0] ,int_DtuFlushB};
  end

always @( posedge clockC )
  begin
    if (rst_bC==0)
      #1 DtuFlush_dlyC =  2'b00;
    else
      #1 DtuFlush_dlyC =  {DtuFlush_dlyC[0] ,int_DtuFlushC};
  end
assign DtuFlushA =  int_DtuFlushA|DtuFlush_dlyA[1] ;
assign DtuFlushB =  int_DtuFlushB|DtuFlush_dlyB[1] ;
assign DtuFlushC =  int_DtuFlushC|DtuFlush_dlyC[1] ;

always @( posedge clockA )
  begin
    if (cnt_rstA==1)
      counterA =  3'b000;
    else
      counterA =  counterA+1;
  end

always @( posedge clockB )
  begin
    if (cnt_rstB==1)
      counterB =  3'b000;
    else
      counterB =  counterB+1;
  end

always @( posedge clockC )
  begin
    if (cnt_rstC==1)
      counterC =  3'b000;
    else
      counterC =  counterC+1;
  end
assign cnt_eocA =  (counterA==3'b111) ? 1'b1 : 1'b0;
assign cnt_eocB =  (counterB==3'b111) ? 1'b1 : 1'b0;
assign cnt_eocC =  (counterC==3'b111) ? 1'b1 : 1'b0;

always @( posedge clockA )
  begin
    if (TPcnt_rstA==1'b1)
      TP_counterA =  10'h000;
    else
      if (TPcnt_cenA==1'b1)
        TP_counterA =  TP_counterA+1;
  end

always @( posedge clockB )
  begin
    if (TPcnt_rstB==1'b1)
      TP_counterB =  10'h000;
    else
      if (TPcnt_cenB==1'b1)
        TP_counterB =  TP_counterB+1;
  end

always @( posedge clockC )
  begin
    if (TPcnt_rstC==1'b1)
      TP_counterC =  10'h000;
    else
      if (TPcnt_cenC==1'b1)
        TP_counterC =  TP_counterC+1;
  end
assign TPcnt_eocA =  (TP_counterA=={TP_lenA,2'b11}) ? 1'b1 : 1'b0;
assign TPcnt_eocB =  (TP_counterB=={TP_lenB,2'b11}) ? 1'b1 : 1'b0;
assign TPcnt_eocC =  (TP_counterC=={TP_lenC,2'b11}) ? 1'b1 : 1'b0;

SU_mVoter rst_bVoter (
    .inA(rst_bA),
    .inB(rst_bB),
    .inC(rst_bC),
    .out(rst_b),
    .tmrErr(rst_bTmrError)
    );

SU_mVoter clockVoter (
    .inA(clockA),
    .inB(clockB),
    .inC(clockC),
    .out(clock),
    .tmrErr(clockTmrError)
    );

SU_mVoter int_TmrErrOutVoter (
    .inA(int_TmrErrOutA),
    .inB(int_TmrErrOutB),
    .inC(int_TmrErrOutC),
    .out(int_TmrErrOut),
    .tmrErr(int_TmrErrOutTmrError)
    );

SU_mVoter #(.WIDTH(4)) nState1VoterA (
    .inA(nState1A),
    .inB(nState1B),
    .inC(nState1C),
    .out(nState1VotedA),
    .tmrErr(nState1TmrErrorA)
    );

SU_mVoter #(.WIDTH(2)) nState0VoterA (
    .inA(nState0A),
    .inB(nState0B),
    .inC(nState0C),
    .out(nState0VotedA),
    .tmrErr(nState0TmrErrorA)
    );

SU_mVoter #(.WIDTH(2)) nState0VoterB (
    .inA(nState0A),
    .inB(nState0B),
    .inC(nState0C),
    .out(nState0VotedB),
    .tmrErr(nState0TmrErrorB)
    );

SU_mVoter #(.WIDTH(4)) nState1VoterB (
    .inA(nState1A),
    .inB(nState1B),
    .inC(nState1C),
    .out(nState1VotedB),
    .tmrErr(nState1TmrErrorB)
    );

SU_mVoter #(.WIDTH(4)) nState1VoterC (
    .inA(nState1A),
    .inB(nState1B),
    .inC(nState1C),
    .out(nState1VotedC),
    .tmrErr(nState1TmrErrorC)
    );

SU_mVoter #(.WIDTH(2)) nState0VoterC (
    .inA(nState0A),
    .inB(nState0B),
    .inC(nState0C),
    .out(nState0VotedC),
    .tmrErr(nState0TmrErrorC)
    );

fanout #(.WIDTH(5)) TmrErrInFanout (
    .in(TmrErrIn),
    .outA(TmrErrInA),
    .outB(TmrErrInB),
    .outC(TmrErrInC)
    );

fanout #(.WIDTH(8)) TP_lenFanout (
    .in(TP_len),
    .outA(TP_lenA),
    .outB(TP_lenB),
    .outC(TP_lenC)
    );
endmodule

module HammingDecoder4TMR #(
  parameter NBits=4,
  parameter NBitsEnc=8
)(
  input [NBitsEnc-1:0] data_encA,
  input [NBitsEnc-1:0] data_encB,
  input [NBitsEnc-1:0] data_encC,
  output [NBits-1:0] data_outA,
  output [NBits-1:0] data_outB,
  output [NBits-1:0] data_outC,
  output  SEU_errorA,
  output  SEU_errorB,
  output  SEU_errorC
);
wire [NBitsEnc-NBits-1:0] parity_outA;
wire [NBitsEnc-NBits-1:0] parity_outB;
wire [NBitsEnc-NBits-1:0] parity_outC;
reg  [NBitsEnc-1:0] correctionA;
reg  [NBitsEnc-1:0] correctionB;
reg  [NBitsEnc-1:0] correctionC;
assign data_outA[0]  =  data_encA[2] ^correctionA[2] ;
assign data_outB[0]  =  data_encB[2] ^correctionB[2] ;
assign data_outC[0]  =  data_encC[2] ^correctionC[2] ;
assign data_outA[3:1]  =  data_encA[6:4] ^correctionA[6:4] ;
assign data_outB[3:1]  =  data_encB[6:4] ^correctionB[6:4] ;
assign data_outC[3:1]  =  data_encC[6:4] ^correctionC[6:4] ;
assign parity_outA[0]  =  data_encA[0] ^data_encA[2] ^data_encA[4] ^data_encA[6] ;
assign parity_outB[0]  =  data_encB[0] ^data_encB[2] ^data_encB[4] ^data_encB[6] ;
assign parity_outC[0]  =  data_encC[0] ^data_encC[2] ^data_encC[4] ^data_encC[6] ;
assign parity_outA[1]  =  data_encA[1] ^data_encA[2] ^data_encA[5] ^data_encA[6] ;
assign parity_outB[1]  =  data_encB[1] ^data_encB[2] ^data_encB[5] ^data_encB[6] ;
assign parity_outC[1]  =  data_encC[1] ^data_encC[2] ^data_encC[5] ^data_encC[6] ;
assign parity_outA[2]  =  data_encA[3] ^data_encA[4] ^data_encA[5] ^data_encA[6] ;
assign parity_outB[2]  =  data_encB[3] ^data_encB[4] ^data_encB[5] ^data_encB[6] ;
assign parity_outC[2]  =  data_encC[3] ^data_encC[4] ^data_encC[5] ^data_encC[6] ;
assign parity_outA[3]  =  data_encA[7] ;
assign parity_outB[3]  =  data_encB[7] ;
assign parity_outC[3]  =  data_encC[7] ;
assign SEU_errorA =  parity_outA[3] |parity_outA[2] |parity_outA[1] |parity_outA[0] ;
assign SEU_errorB =  parity_outB[3] |parity_outB[2] |parity_outB[1] |parity_outB[0] ;
assign SEU_errorC =  parity_outC[3] |parity_outC[2] |parity_outC[1] |parity_outC[0] ;

always @( parity_outA )
  begin
    case (parity_outA)
      4'b0000 : correctionA =  8'b00000000;
      4'b0001 : correctionA =  8'b00000001;
      4'b0010 : correctionA =  8'b00000010;
      4'b0011 : correctionA =  8'b00000100;
      4'b0100 : correctionA =  8'b00001000;
      4'b0101 : correctionA =  8'b00010000;
      4'b0110 : correctionA =  8'b00100000;
      4'b0111 : correctionA =  8'b01000000;
      4'b1000 : correctionA =  8'b10000000;
      default : correctionA =  8'b00000000;
    endcase
  end

always @( parity_outB )
  begin
    case (parity_outB)
      4'b0000 : correctionB =  8'b00000000;
      4'b0001 : correctionB =  8'b00000001;
      4'b0010 : correctionB =  8'b00000010;
      4'b0011 : correctionB =  8'b00000100;
      4'b0100 : correctionB =  8'b00001000;
      4'b0101 : correctionB =  8'b00010000;
      4'b0110 : correctionB =  8'b00100000;
      4'b0111 : correctionB =  8'b01000000;
      4'b1000 : correctionB =  8'b10000000;
      default : correctionB =  8'b00000000;
    endcase
  end

always @( parity_outC )
  begin
    case (parity_outC)
      4'b0000 : correctionC =  8'b00000000;
      4'b0001 : correctionC =  8'b00000001;
      4'b0010 : correctionC =  8'b00000010;
      4'b0011 : correctionC =  8'b00000100;
      4'b0100 : correctionC =  8'b00001000;
      4'b0101 : correctionC =  8'b00010000;
      4'b0110 : correctionC =  8'b00100000;
      4'b0111 : correctionC =  8'b01000000;
      4'b1000 : correctionC =  8'b10000000;
      default : correctionC =  8'b00000000;
    endcase
  end
endmodule



// /export/elt153xl/disk0/users/gianni/projects/LiTE-DTU/tmrg/src/../common/voter.v
module SU_mVoter (inA, inB, inC, out, tmrErr);
  parameter WIDTH = 1;
  input   [(WIDTH-1):0]   inA, inB, inC;
  output  [(WIDTH-1):0]   out;
  output                  tmrErr;
  reg                     tmrErr;
  assign out = (inA&inB) | (inA&inC) | (inB&inC);
  always @(inA or inB or inC)
  begin
    if (inA!=inB || inA!=inC || inB!=inC)
      tmrErr = 1;
    else
      tmrErr = 0;
  end
endmodule


// /export/elt153xl/disk0/users/gianni/projects/LiTE-DTU/tmrg/src/../common/fanout.v
module fanout (in, outA, outB, outC);
  parameter WIDTH = 1;
  input   [(WIDTH-1):0]   in;
  output  [(WIDTH-1):0]   outA,outB,outC;
  assign outA=in;
  assign outB=in;
  assign outC=in;
endmodule
