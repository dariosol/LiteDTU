/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ../LiteDTUv2_0_AUTOTMR/5_1_LDTU_Hamm_oFIFOTMR.v                                        *
 *                                                                                                  *
 * user    : soldi                                                                                  *
 * host    : elt159xl.to.infn.it                                                                    *
 * date    : 03/03/2021 13:21:37                                                                    *
 *                                                                                                  *
 * workdir : /export/elt159xl/disk0/users/soldi/LiTE-DTU_v2.0_2021_Simulations/pre-synth/LiteDTUv2_0_NoTMR *
 * cmd     : /export/elt159xl/disk0/users/soldi/LiTE-DTU_v2.0_2021_Simulations/tmrg/bin/tmrg -c     *
 *           tmr_Config/Last_DTU_v2.cfg --tmr-dir=../LiteDTUv2_0_AUTOTMR/                           *
 * tmrg rev: ececa199b20e3753893c07f87ef839ce926b269f                                               *
 *                                                                                                  *
 * src file: 5_1_LDTU_Hamm_oFIFO.v                                                                  *
 *           File is NOT under version control!                                                     *
 *           Modification time : 2021-03-02 09:01:12.510427                                         *
 *           File Size         : 3473                                                               *
 *           MD5 hash          : e4cb2d79f8e4abc509f8ea684da673b9                                   *
 *                                                                                                  *
 ****************************************************************************************************/

`timescale       1ps/1ps

module LDTU_oFIFOTMR(
  CLKA,
  CLKB,
  CLKC,
  rst_bA,
  rst_bB,
  rst_bC,
  start_writeA,
  start_writeB,
  start_writeC,
  read_signalA,
  read_signalB,
  read_signalC,
  data_inputA,
  data_inputB,
  data_inputC,
  data_output,
  empty_signalA,
  empty_signalB,
  empty_signalC,
  full_signalA,
  full_signalB,
  full_signalC,
  decode_signalA,
  decode_signalB,
  decode_signalC,
  SeuError
);
parameter    Nbits_ham=38;
parameter    FifoDepth_buff=16;
parameter    bits_ptr=4;
wire tmrError;
wor start_writeTmrError;
wor rst_bTmrError;
wor ptr_writeTmrError;
wor ptr_readTmrError;
wor full_signalTmrError;
wor data_inputTmrError;
wor CLKTmrError;
wire [Nbits_ham-1:0] data_input;
wire CLK;
wire [bits_ptr-1:0] ptr_read;
wire full_signal;
wire [bits_ptr-1:0] ptr_write;
wire start_write;
wire rst_b;
output SeuError;
output empty_signalA;
output empty_signalB;
output empty_signalC;
output full_signalA;
output full_signalB;
output full_signalC;
output reg   [Nbits_ham-1:0] data_output;
output reg    decode_signalA;
output reg    decode_signalB;
output reg    decode_signalC;
input CLKA;
input CLKB;
input CLKC;
input rst_bA;
input rst_bB;
input rst_bC;
input start_writeA;
input start_writeB;
input start_writeC;
input read_signalA;
input read_signalB;
input read_signalC;
input [Nbits_ham-1:0] data_inputA;
input [Nbits_ham-1:0] data_inputB;
input [Nbits_ham-1:0] data_inputC;
reg  [bits_ptr-1:0] ptr_writeA;
reg  [bits_ptr-1:0] ptr_writeB;
reg  [bits_ptr-1:0] ptr_writeC;
reg  [bits_ptr-1:0] ptr_readA;
reg  [bits_ptr-1:0] ptr_readB;
reg  [bits_ptr-1:0] ptr_readC;
reg  [Nbits_ham-1:0] memory [ FifoDepth_buff-1 : 0 ] ;
assign SeuError =  tmrError;
assign empty_signalA =  (ptr_readA==ptr_writeA);
assign empty_signalB =  (ptr_readB==ptr_writeB);
assign empty_signalC =  (ptr_readC==ptr_writeC);
assign full_signalA =  ((ptr_readA==ptr_writeA+4'b1)||((ptr_readA==4'b0)&&(ptr_writeA==(4'b1111))));
assign full_signalB =  ((ptr_readB==ptr_writeB+4'b1)||((ptr_readB==4'b0)&&(ptr_writeB==(4'b1111))));
assign full_signalC =  ((ptr_readC==ptr_writeC+4'b1)||((ptr_readC==4'b0)&&(ptr_writeC==(4'b1111))));

always @( posedge CLKA )
  begin
    if (rst_bA==1'b0)
      ptr_writeA <= 4'b0;
    else
      begin
        if (start_writeA==1'b1)
          begin
            if (full_signalA==1'b0)
              ptr_writeA <= ptr_writeA+4'b1;
            else
              ptr_writeA <= ptr_writeA;
          end
        else
          ptr_writeA <= ptr_writeA;
      end
  end

always @( posedge CLKB )
  begin
    if (rst_bB==1'b0)
      ptr_writeB <= 4'b0;
    else
      begin
        if (start_writeB==1'b1)
          begin
            if (full_signalB==1'b0)
              ptr_writeB <= ptr_writeB+4'b1;
            else
              ptr_writeB <= ptr_writeB;
          end
        else
          ptr_writeB <= ptr_writeB;
      end
  end

always @( posedge CLKC )
  begin
    if (rst_bC==1'b0)
      ptr_writeC <= 4'b0;
    else
      begin
        if (start_writeC==1'b1)
          begin
            if (full_signalC==1'b0)
              ptr_writeC <= ptr_writeC+4'b1;
            else
              ptr_writeC <= ptr_writeC;
          end
        else
          ptr_writeC <= ptr_writeC;
      end
  end

always @( posedge CLKA )
  begin
    if (rst_bA==1'b0)
      begin
        ptr_readA <= 4'b0;
        decode_signalA <= 1'b0;
      end
    else
      begin
        if (read_signalA==1'b1)
          begin
            if (empty_signalA==1'b0)
              begin
                ptr_readA <= ptr_readA+4'b1;
                decode_signalA <= 1'b1;
              end
            else
              begin
                ptr_readA <= ptr_readA;
                decode_signalA <= 1'b0;
              end
          end
        else
          begin
            ptr_readA <= ptr_readA;
            decode_signalA <= 1'b0;
          end
      end
  end

always @( posedge CLKB )
  begin
    if (rst_bB==1'b0)
      begin
        ptr_readB <= 4'b0;
        decode_signalB <= 1'b0;
      end
    else
      begin
        if (read_signalB==1'b1)
          begin
            if (empty_signalB==1'b0)
              begin
                ptr_readB <= ptr_readB+4'b1;
                decode_signalB <= 1'b1;
              end
            else
              begin
                ptr_readB <= ptr_readB;
                decode_signalB <= 1'b0;
              end
          end
        else
          begin
            ptr_readB <= ptr_readB;
            decode_signalB <= 1'b0;
          end
      end
  end

always @( posedge CLKC )
  begin
    if (rst_bC==1'b0)
      begin
        ptr_readC <= 4'b0;
        decode_signalC <= 1'b0;
      end
    else
      begin
        if (read_signalC==1'b1)
          begin
            if (empty_signalC==1'b0)
              begin
                ptr_readC <= ptr_readC+4'b1;
                decode_signalC <= 1'b1;
              end
            else
              begin
                ptr_readC <= ptr_readC;
                decode_signalC <= 1'b0;
              end
          end
        else
          begin
            ptr_readC <= ptr_readC;
            decode_signalC <= 1'b0;
          end
      end
  end

always @( posedge CLK )
  begin
    if (rst_b==1'b0)
      memory[ptr_write]  <= 38'b0;
    else
      begin
        if (start_write==1'b1)
          begin
            if (full_signal==1'b0)
              memory[ptr_write]  <= data_input;
          end
      end
  end

always @( posedge CLK )
  begin
    if (rst_b==1'b0)
      data_output =  38'b01000000000000000000000000000000;
    else
      data_output =  memory[ptr_read] ;
  end

majorityVoter rst_bVoter (
    .inA(rst_bA),
    .inB(rst_bB),
    .inC(rst_bC),
    .out(rst_b),
    .tmrErr(rst_bTmrError)
    );

majorityVoter start_writeVoter (
    .inA(start_writeA),
    .inB(start_writeB),
    .inC(start_writeC),
    .out(start_write),
    .tmrErr(start_writeTmrError)
    );

majorityVoter #(.WIDTH(((bits_ptr-1)>(0)) ? ((bits_ptr-1)-(0)+1) : ((0)-(bits_ptr-1)+1))) ptr_writeVoter (
    .inA(ptr_writeA),
    .inB(ptr_writeB),
    .inC(ptr_writeC),
    .out(ptr_write),
    .tmrErr(ptr_writeTmrError)
    );

majorityVoter full_signalVoter (
    .inA(full_signalA),
    .inB(full_signalB),
    .inC(full_signalC),
    .out(full_signal),
    .tmrErr(full_signalTmrError)
    );

majorityVoter #(.WIDTH(((bits_ptr-1)>(0)) ? ((bits_ptr-1)-(0)+1) : ((0)-(bits_ptr-1)+1))) ptr_readVoter (
    .inA(ptr_readA),
    .inB(ptr_readB),
    .inC(ptr_readC),
    .out(ptr_read),
    .tmrErr(ptr_readTmrError)
    );

majorityVoter CLKVoter (
    .inA(CLKA),
    .inB(CLKB),
    .inC(CLKC),
    .out(CLK),
    .tmrErr(CLKTmrError)
    );

majorityVoter #(.WIDTH(((Nbits_ham-1)>(0)) ? ((Nbits_ham-1)-(0)+1) : ((0)-(Nbits_ham-1)+1))) data_inputVoter (
    .inA(data_inputA),
    .inB(data_inputB),
    .inC(data_inputC),
    .out(data_input),
    .tmrErr(data_inputTmrError)
    );
assign tmrError =  CLKTmrError|data_inputTmrError|full_signalTmrError|ptr_readTmrError|ptr_writeTmrError|rst_bTmrError|start_writeTmrError;
endmodule

