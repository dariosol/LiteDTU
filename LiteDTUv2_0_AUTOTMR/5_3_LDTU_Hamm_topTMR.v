/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ../LiteDTUv2_0_AUTOTMR/5_3_LDTU_Hamm_topTMR.v                                          *
 *                                                                                                  *
 * user    : soldi                                                                                  *
 * host    : elt159xl.to.infn.it                                                                    *
 * date    : 03/03/2021 13:21:38                                                                    *
 *                                                                                                  *
 * workdir : /export/elt159xl/disk0/users/soldi/LiTE-DTU_v2.0_2021_Simulations/pre-synth/LiteDTUv2_0_NoTMR *
 * cmd     : /export/elt159xl/disk0/users/soldi/LiTE-DTU_v2.0_2021_Simulations/tmrg/bin/tmrg -c     *
 *           tmr_Config/Last_DTU_v2.cfg --tmr-dir=../LiteDTUv2_0_AUTOTMR/                           *
 * tmrg rev: ececa199b20e3753893c07f87ef839ce926b269f                                               *
 *                                                                                                  *
 * src file: 5_3_LDTU_Hamm_top.v                                                                    *
 *           File is NOT under version control!                                                     *
 *           Modification time : 2021-03-02 11:22:57.935295                                         *
 *           File Size         : 3249                                                               *
 *           MD5 hash          : a10c99e07a8b4ca9b63ac97127e2dabe                                   *
 *                                                                                                  *
 ****************************************************************************************************/

`timescale   1ps/1ps

module LDTU_oFIFO_topTMR(
  CLK,
  rst_b,
  write_signal,
  read_signal,
  data_in_32,
  DATA32_DTUA,
  DATA32_DTUB,
  DATA32_DTUC,
  full_signalA,
  full_signalB,
  full_signalC,
  SeuError
);
parameter    Nbits_32=32;
parameter    Nbits_ham=38;
parameter    FifoDepth_buff=16;
parameter    bits_ptr=4;
parameter    idle_patternEA=32'b11101010101010101010101010101010;
parameter    idle_pattern5A=32'b01011010010110100101101001011010;
wire [Nbits_32-1:0] data_out_32C;
wire [Nbits_32-1:0] data_out_32B;
wire [Nbits_32-1:0] data_out_32A;
wire read_signalC;
wire read_signalB;
wire read_signalA;
wire CLKC;
wire CLKB;
wire CLKA;
wire rst_bC;
wire rst_bB;
wire rst_bA;
wire start_writeC;
wire start_writeB;
wire start_writeA;
wire [Nbits_ham-1:0] data_in_38C;
wire [Nbits_ham-1:0] data_in_38B;
wire [Nbits_ham-1:0] data_in_38A;
wire tmrError;
wor decode_signalTmrError;
wire decode_signalB;
wire decode_signalC;
wire decode_signalA;
input CLK;
input rst_b;
input write_signal;
input read_signal;
input [Nbits_32-1:0] data_in_32;
output reg   [Nbits_32-1:0] DATA32_DTUA;
output reg   [Nbits_32-1:0] DATA32_DTUB;
output reg   [Nbits_32-1:0] DATA32_DTUC;
output full_signalA;
output full_signalB;
output full_signalC;
output SeuError;
wire CLK;
wire reset;
wire [Nbits_ham-1:0] data_in_38;
wire [Nbits_ham-1:0] data_out_38;
wire [Nbits_32-1:0] data_out_32;
wire start_write;
wire HammError;
wire tmrError_oFIFO;
wire read_signal;
wire empty_signalA;
wire empty_signalB;
wire empty_signalC;
wire decode_signal;
assign SeuError =  tmrError|tmrError_oFIFO;

Hamm_TRX #(.Nbits_32(Nbits_32), .Nbits_ham(Nbits_ham)) Hamming_32_38 (
    .CLK(CLK),
    .reset(rst_b),
    .data_input(data_in_32),
    .data_ham_in(data_in_38),
    .write_signal(write_signal),
    .start_write(start_write)
    );

LDTU_oFIFOTMR #(.Nbits_ham(Nbits_ham)) FIFO (
    .CLKA(CLKA),
    .CLKB(CLKB),
    .CLKC(CLKC),
    .rst_bA(rst_bA),
    .rst_bB(rst_bB),
    .rst_bC(rst_bC),
    .start_writeA(start_writeA),
    .start_writeB(start_writeB),
    .start_writeC(start_writeC),
    .read_signalA(read_signalA),
    .read_signalB(read_signalB),
    .read_signalC(read_signalC),
    .data_inputA(data_in_38A),
    .data_inputB(data_in_38B),
    .data_inputC(data_in_38C),
    .data_output(data_out_38),
    .full_signalA(full_signalA),
    .full_signalB(full_signalB),
    .full_signalC(full_signalC),
    .decode_signalA(decode_signalA),
    .decode_signalB(decode_signalB),
    .decode_signalC(decode_signalC),
    .SeuError(tmrError_oFIFO),
    .empty_signalA(empty_signalA),
    .empty_signalB(empty_signalB),
    .empty_signalC(empty_signalC)
    );

Hamm_RX #(.Nbits_32(Nbits_32), .Nbits_ham(Nbits_ham)) Hamming_38_32 (
    .CLK(CLK),
    .reset(rst_b),
    .decode_signal(decode_signal),
    .data_ham_out(data_out_38),
    .data_output(data_out_32),
    .HammError(HammError)
    );

always @( posedge CLKA )
  begin
    if (rst_bA==1'b0)
      begin
        DATA32_DTUA =  idle_patternEA;
      end
    else
      begin
        if (read_signalA==1'b1)
          begin
            if (empty_signalA==1'b1)
              begin
                DATA32_DTUA =  idle_patternEA;
              end
            else
              begin
                DATA32_DTUA =  data_out_32A;
              end
          end
      end
  end

always @( posedge CLKB )
  begin
    if (rst_bB==1'b0)
      begin
        DATA32_DTUB =  idle_patternEA;
      end
    else
      begin
        if (read_signalB==1'b1)
          begin
            if (empty_signalB==1'b1)
              begin
                DATA32_DTUB =  idle_patternEA;
              end
            else
              begin
                DATA32_DTUB =  data_out_32B;
              end
          end
      end
  end

always @( posedge CLKC )
  begin
    if (rst_bC==1'b0)
      begin
        DATA32_DTUC =  idle_patternEA;
      end
    else
      begin
        if (read_signalC==1'b1)
          begin
            if (empty_signalC==1'b1)
              begin
                DATA32_DTUC =  idle_patternEA;
              end
            else
              begin
                DATA32_DTUC =  data_out_32C;
              end
          end
      end
  end

majorityVoter decode_signalVoter (
    .inA(decode_signalA),
    .inB(decode_signalB),
    .inC(decode_signalC),
    .out(decode_signal),
    .tmrErr(decode_signalTmrError)
    );
assign tmrError =  decode_signalTmrError;

fanout #(.WIDTH(((Nbits_ham-1)>(0)) ? ((Nbits_ham-1)-(0)+1) : ((0)-(Nbits_ham-1)+1))) data_in_38Fanout (
    .in(data_in_38),
    .outA(data_in_38A),
    .outB(data_in_38B),
    .outC(data_in_38C)
    );

fanout start_writeFanout (
    .in(start_write),
    .outA(start_writeA),
    .outB(start_writeB),
    .outC(start_writeC)
    );

fanout rst_bFanout (
    .in(rst_b),
    .outA(rst_bA),
    .outB(rst_bB),
    .outC(rst_bC)
    );

fanout CLKFanout (
    .in(CLK),
    .outA(CLKA),
    .outB(CLKB),
    .outC(CLKC)
    );

fanout read_signalFanout (
    .in(read_signal),
    .outA(read_signalA),
    .outB(read_signalB),
    .outC(read_signalC)
    );

fanout #(.WIDTH(((Nbits_32-1)>(0)) ? ((Nbits_32-1)-(0)+1) : ((0)-(Nbits_32-1)+1))) data_out_32Fanout (
    .in(data_out_32),
    .outA(data_out_32A),
    .outB(data_out_32B),
    .outC(data_out_32C)
    );
endmodule

